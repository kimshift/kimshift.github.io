---
title: 常用正则表达式
date: 2023-06-02 18:00:22
categories:
  - 前端开发
tags:
  - 正则表达式
sticky: 3
---

## 1. 正则表达式概述

### 1.1 什么是正则表达式

**正则表达式（ Regular Expression ）**是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。

正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(**匹配**)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(**替换**)，或从字符串中获取我们想要的特定部分(**提取**)等 。

其他语言也会使用正则表达式，本阶段我们主要是利用 JavaScript 正则表达式完成表单验证。

### 1.2 正则表达式的特点

1. 灵活性、逻辑性和功能性非常的强。
2. 可以迅速地用极简单的方式达到字符串的复杂控制。
3. 对于刚接触的人来说，比较晦涩难懂。比如： ^\w+([-+.]\w+)_@\w+([-.]\w+)_\.\w+([-.]\w+)\*$
4. 实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式. 比如用户名: /^[a-z0-9_-]{3,16}$/

## 2. 正则表达式在 JavaScript 中的使用

### 2.1 创建正则表达式

在 JavaScript 中，可以通过两种方式创建一个正则表达式。

1. 通过调用 RegExp 对象的构造函数创建

```
   var 变量名 = new RegExp(/表达式/);
```

2. 通过字面量创建

```
   var 变量名 = /表达式/;
```

// 注释中间放表达式就是正则字面量

### 2.2 测试正则表达式 test

test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。

```
   regexObj.test(str)
```

1. regexObj 是写的正则表达式
2. str 我们要测试的文本
3. 就是检测 str 文本是否符合我们写的正则表达式规范.

PS:模糊查询案例

```javascript
let arg = '张',
  re = new RegExp(arg)
let arr = [
  { name: '张三', age: 18 },
  { name: '张三丰', age: 100 },
  { name: '李四', age: 18 },
]
let newArr = arr.filter(item => {
  if (re.test(item.name)) return item //返回name:带有张字的数据
})
console.log(newArr)
```

PS:精确查询案例

```javascript
let re = /^张三$/
let arr = [
  { name: '张三', age: 18 },
  { name: '张三丰', age: 100 },
  { name: '李四', age: 18 },
]
let newArr = arr.filter(item => {
  if (re.test(item.name)) return item
})
console.log(newArr)
```

## 3. 正则表达式中的特殊字符

### 3.1 正则表达式的组成

一个正则表达式**可以由简单的字符构成**，比如 /abc/，**也可以是简单和特殊字符的组合**，比如 /ab\*c/ 。其中特殊字符也被称为**元字符**，在正则表达式中是具有**特殊**意义的专用**符号**，如 ^ 、$ 、+ 等。

特殊字符非常多，可以参考：
MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions
jQuery 手册：正则表达式部分
正则测试工具: http://tool.oschina.net/regex

### 3.2 边界符

正则表达式中的边界符（位置符）用来**提示字符所处的位置**，主要有两个字符。

| 边界符 | 说明                         |
| ------ | ---------------------------- |
| ^      | 表示匹配行首的文本(以谁开始) |
| $      | 表示匹配行尾的文本(以谁结束) |

如果 ^ 和 $ 在一起，表示必须是精确匹配。

### 3.3 字符类

字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。**所有可供选择的字符都放在方括号内**。

1. [] 方括号

```
   /[abc]/.test('andy')     // true
```

后面的字符串只要包含 abc 中任意一个字符，都返回 true 。

2. [-] 方括号内部 范围符-

```
   /^[a-z]$/.test(c')     // true
```

方括号内部加上 - 表示**范围**，这里表示 **a 到 z** 26 个英文字母都可以。

3. [^] 方括号内部 取反符^

```
   /[^abc]/.test('andy')     // false
```

方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。

**注意和边界符 ^ 区别，边界符写到方括号外面。**

4. 字符组合

```
   /[a-z1-9]/.test('andy')     // true
```

方括号内部可以使用字符组合，这里表示包含 a 到 z 的 26 个英文字母和 1 到 9 的数字都可以。

### 3.4 量词符

量词符用来**设定某个模式出现的次数**。

| 量词  | 说明                                                                                         |
| ----- | -------------------------------------------------------------------------------------------- |
| \*    | 重复零次或更多次                                                                             |
| +     | 重复一次或更多次                                                                             |
| ?     | 重复零次或一次                                                                               |
| {n}   | 重复 n 次                                                                                    |
| {n,}  | 重复 n 次或更多次                                                                            |
| {n,m} | 重复 n 到 m 次                                                                               |
| ()    | 表示捕获分组,会把每个分组里的匹配的值保存起来，使用$n(n 是一个数字，表示第 n 个捕获组的内容) |
| (?:)  | 表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来                     |

```javascript
'1234567890'.replace(/\B(?=(?:\d{3})+(?!\d))/g, ',') // 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)
```

**☆ 前瞻后顾:(?<=exp) 表示匹配 exp 之后的，(?=exp)表示匹配 exp 之前的**

```JavaScript
let str="hi!你是谁,ws中国r,ws中国r."
/* 前瞻语法:exp1(?=exp2) 查找exp2前面的exp1 */
let reg1=/[A-Za-z]+(?=中国)/g //匹配中国前面相接的英文字段
//将中国前面相接的英文替换成我是
console.log('前瞻:',str.replace(reg1,"我是"))//测试: hi!你是谁,我是中国人我是中国人

/* 后顾语法:(?<=exp2)exp1 查找exp2后面的exp1 */
let reg2=/(?<=中国)[A-Za-z]+/g //匹配中国后面相接的英文字段/
//将中国后面相接的英文替换成人
console.log('后顾:',str.replace(reg2,"人"))//测试: hi!你是谁,我是中国人我是中国人

/* 负前瞻语法:exp1(?!exp2) 查找后面不是exp2的exp1 */
let reg3=/[A-Za-z]+(?!中国)/ //匹配第一个后面不与中国相接的英文字段
// 后面不与中国相接的英文替换成你好
console.log('负前瞻:',str.replace(reg3,"你好"))//负前瞻: 你好!你是谁,你好s中国你好,你好s中国你好.

/* 负后顾语法:(?<!exp2)exp1 查找前面不是exp2的exp1*/
let reg4=/(?!中国)[A-Za-z]+/ //匹配第一个前面不与中国相接的英文字段/
console.log('负后顾:',str.replace(reg4,'你好'))//负后顾: 你好!你是谁,ws中国r,ws中国r.
```

**☆ 匹配两个字符串之间的值**

```javascript
/*******
 * @description: [正则匹配两字符串之间的值]
 * @author: 琴时
 */
let str =
  '打酱油AX我们是大写埃克斯(x)到大写歪(y)之间的值Y打酱油B,匹配X到Y之间的字符串'
/* 匹配变量 */
const startStr = 'X'
const endStr = 'Y'
/* 匹配两个字符串X与Y中间的字符串包含X与Y*/
const reg = /X.*?Y/g //"."表示任意字符、"*"表示重复零次或更多次、"?"表示重复零次或一次
const pattern = new RegExp(`${startStr}.*?${endStr}`, 'g') //与reg等价
console.log('测试:', str.match(reg)) //测试: [ 'X我们是大写埃克斯(x)到大写歪(y)之间的值Y', 'X到Y' ]
console.log('测试:', str.match(pattern)) //测试: [ 'X我们是大写埃克斯(x)到大写歪(y)之间的值Y', 'X到Y' ]

/* 匹配两个字符串X与Y中间的字符串包含X但是不包含Y */
const reg1 = /X.*?(?=Y)/g //".*?"解释同上reg描述、前瞻语法:str(?=Y) 查找Y前面的str
const pattern1 = new RegExp(`${startStr}.*?(?=${endStr})`, 'g') //与reg1等价
console.log('测试:', str.match(reg1)) //测试: [ 'X我们是大写埃克斯(x)到大写歪(y)之间的值', 'X到' ]
console.log('测试:', str.match(pattern1)) //测试: [ 'X我们是大写埃克斯(x)到大写歪(y)之间的值', 'X到' ]

/* 匹配两个字符串X与Y中间的字符串且不包含X与Y */
const reg2 = /(?<=X).*?(?=Y)/g //后顾语法:(?<=X)str 查找X后面的str、".*?(?=Y)"解释同上reg1描述
const pattern2 = new RegExp(`(?<=${startStr}).*?(?=${endStr})`, 'g') //与reg2等价
console.log('测试:', str.match(reg2)) //测试: [ '我们是大写埃克斯(x)到大写歪(y)之间的值', '到' ]
console.log('测试:', str.match(pattern2)) //测试: [ '我们是大写埃克斯(x)到大写歪(y)之间的值', '到' ]
```

### 3.5 括号总结

1. 大括号 量词符. 里面表示重复次数
2. 中括号 字符集合。匹配方括号中的任意字符.
3. 小括号 表示优先级

可以在线测试: https://c.runoob.com/

### 3.6 预定义类

预定义类指的是**某些常见模式的简写方式**。

| 预定类 | 说明                                                       |
| ------ | ---------------------------------------------------------- |
| \d     | 匹配 0-9 之间的任意数字，相当于[0-9]                       |
| \D     | 匹配所有 0-9 以外的字符，相当于`[^O-9]`                    |
| \w     | 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]           |
| \W     | 除所有字母、数字和下划线以外的字符，相当于〔^A-Za-z0-9\_]  |
| \s     | 匹配空格包括换行符、制表符、空格符等)，相等于[ \t\r\n\v\f] |
| \S     | 匹配非空格的字符，相当于`[^\t\r\n\v\f]`                    |

## 4. 正则表达式中的替换

### 4.1 replace 替换

replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。

```
   stringObject.replace(regexp/substr,replacement)
```

1. 第一个参数: 被替换的字符串 或者 正则表达式

2. 第二个参数: 替换为的字符串

3. 返回值是一个替换完毕的新字符串

   ```javascript
   //把 "Doe, John" 转换为 "John Doe" 的形式：
   let str = "Doe, John";
   console.log('测试:', str.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1"))
   说明：$1,$2上就是按顺序对应小括号里面的小正则 捕获到的内容。
   ```

### 4.2 正则表达式参数

```
 /表达式/[switch] -->/^[0-9]*$/g
 new RegExp('^[0-9]*$','g')
```

switch(也称为修饰符) 按照什么样的模式来匹配. 有三种值：

- g：全局匹配
- i：忽略大小写
- gi：全局匹配 + 忽略大小写

### 4.3 编写带变量的正则表达式

```javascript
/*校验数字后面接x*/
const params = 'x'
const pattern = new RegExp(`^\\d+${params}$`, 'g') //==>/^\d+x$/g
console.log('测试:', pattern.test('8x')) //true
```

## 5. 常用的正则表达式

### 一、校验数字的表达式

```
须包含大小写字母和数字：/^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).{11}$/

非数字：/^\D*$/

匹配任意位数字：^[0-9]*$

n位的数字：^\d{n}$  （\d与[0-9]意思一样）

至少n位的数字：^\d{n,}$

m-n位的数字：^\d{m,n}$

1开头11位数字：^1\d{11}$

零和非零开头的任意数字：^(0|[1-9]\d*)$

非零开头的最多带两位小数的数字：^([1-9]\d*)+(.\d{1,2})?$

商品价格最多两位小数(^[1-9]\d*(\.\d{1,2})?$)|(^0(\.\d{1,2})?$)

带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$

正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$

有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

非零的正整数：^[1-9]\d*$

非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$

非负整数：^\d+$ 或 ^[1-9]\d*|0$

非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$

非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$

非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$

浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
```

### 二、校验字符的表达式

```
1. 汉字：^[\u4e00-\u9fa5]{0,}$

2. 英文和数字：^[A-Za-z\d]+$ 或 ^[A-Za-z\d]{4,40}$

3. 长度为3-20的所有字符：^.{3,20}$

4. 由26个英文字母组成的字符串：^[A-Za-z]+$

5. 由26个大写英文字母组成的字符串：^[A-Z]+$

6. 由26个小写英文字母组成的字符串：^[a-z]+$

7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$

8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$

9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$

10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$

11. 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+
```

### 三、特殊需求表达式

```
1. 邮箱地址：/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+$/
说明:（英文数字下划线减号+@+英文数字下划线减号+.+英文数字下划线减号）
/^([A-Za-z\d]+[-|_|\.]?)+[A-Za-z\d]@([A-Za-z\d]+(-[A-Za-z\d]+)?\.)+[a-zA-Z]{2,3}$/
说明：至少一位英文/数字开头+0/1位(减号/下划线/点)+英文/数字+@+英文/数字+0/1次(减号+至少一次英文/数字)+2~3位英文
2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?

3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$

4. 手机号码：^1(?:3\d|4[4-9]|5[0-35-9]|6[67]|7[013-8]|8\d|9\d|)\d{8}$
说明：必须1开头+3-9其中一个+限定数字一个（限定说明：3后面可接任意数字；4可接4-9；5可接0-3或者5-9；6可接6或者7；7可接除了2的数字，8或者9可接任意数字）+ 任意数字8个

中国大陆加港澳台手机正则验证：^1(?:3\d|4[4-9]|5[0-35-9]|6[67]|7[013-8]|8\d|9\d|)\d{8}$|^([6|9])\d{7}$|^[6]([8|6])\d{5}$|^[0][9]\d{8}$
香港：9或6开头后面跟7位数字/澳门：66或68开头后面跟5位数字/台湾：09开头后面跟8位数字

5. 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$

6. 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}

7. 身份证号(15位、18位数字)：^\d{15}|\d{18}$

8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$

9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

12. 日期格式：^\d{4}-\d{1,2}-\d{1,2}

简单校验出生日期(1900~2099):/^((19\d{2})|(20\d{2}))\-((0?[1-9])|(1[0-2]))\-((0?[1-9])|([1-2][0-9])|30|31)$/
/^((?:19\d{2})|(?:20\d{2}))\-((?:0?[1-9])|(?:1[0-2]))\-((?:0?[1-9])|(?:[1-2][0-9])|30|31)$/

13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$

14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

15. 钱的输入格式： 有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$
	这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$
	一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$
	这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.
		下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$
	必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$
	这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$
	这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$
	1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$
(^[1-9]\d*(\.\d{1,2})?$)|(^0(\.\d{1,2})?$)
25. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$

26. 中文字符的正则表达式：[\u4e00-\u9fa5]

27. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))

28. 空白行的正则表达式：\n\s*\r (可以用来删除空白行)

29. HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

30. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

31. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)

32. 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)

33. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)

34. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
```
