---
title: 1.javaScript入门
date: 2023-06-02 10:50:11
categories:
  - 前端开发
tags:
  - javascript
  - js基础
prev: false
next: 2.Web APl简介
---

## 1.JavaScript 基础

### 1.组成

- ECMAScript:javascript 语法
- DOM:页面文件对象模型
- BOM:浏览器对象模型

#### 1.ECMAScript

ECMAScript 是由 ECMA 国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。

ECMAScript : ECMAScript 规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准。

#### 2.DOM——文档对象模型

文档对象模型(Document Object Model，简称 DOM）)，是 W3C 组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)。

#### 3.BOM——浏览器对象模型

BOM(Browser ObjectModel，简称 BOM)是指浏览器对象模型，它提供了独立于内容的、可以与**浏览器窗口进行互动的对象结构**。通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。

### 2.变量

- 为什么需要变量?因为我们一些数据需要保存，所以需要变量
- 变量是什么?变量就是一个容器，用来存放数据的。方便我们以后使用里面的数据；
- 变量的本质是什么?变量是内存里的一块空间，用来存数据。
- 变量怎么使用的?我们使用变量的时候，一定要声明变量，然后赋值；声明变量本质是去内存申请空间；
- 什么是变量的初始化?声明变量并赋值我们称之为变量的初始化
- 变量命名规范有哪些？变量名尽量要规范，见名知意——驼峰命名法；区分哪些变量名不合法
- 交换 2 个变量值的思路?学会交换 2 个变量

### 3.数据类型

JavaScript 是一种弱类型或者说动态语言。

JS 把数据类型分为两类 ∶

- 简单数据类型( Number , string ,Boolean, Undefined,Null )
- 复杂数据类型( object)

| 简单数据类型 | 说明                                                 | 默认值    |
| ------------ | ---------------------------------------------------- | --------- |
| Number       | 数字型，包含整型值和浮点型值，如 21、0.21            | 0         |
| Boolean      | 布尔值类型，如 true , false，等价于 1 和 0           | false     |
| String       | 字符串类型，如"张三”注意咱们 js 里面，字符串都带引号 | ""        |
| Undefined    | var a;声明了变量 a 但是没有给值，此时 a = undefined  | undefined |
| Null         | var a = null;声明了变量 a 为空值                     | null      |

isNan(x)==>不是数字返回 true,是数字返货 false;

**遍历字符串**

> 1

```
//遍历字符串
exec 一般用于独立的动作一次性执行,返回 query(find()方法查询返回的是 data)
'Sname': new RegExp(.)//将关键词匹配
newData = results.filter((item) =>item.commodityIntroduction.match(RegExp(/i7/)));
```

### 4.数据类型转换

#### 1.转字符串类型

- num.toString()
- String(num) //强制转换
- num+''

#### 2.转数字类型

- parseInt(str)//取整
- parseFloat(str)//保留小数
- Number(str)//强制转换(str 必须是数字型字符串否则返回 NaN)
- 'str'-0=str//减乘除(str 必须是数字型字符串)

数字类型字符串转数字："6"+0==>6

#### 3.转换为布尔值

- 代表空、否定的值会被转换为 false ,如"、0、NaN、null、undefined
- 其余值都会被转换为 true

### 5.标识符、关键字、保留字

#### 1.标识符

标识(zhi)符 ∶ 就是指开发人员为变量、属性、函数、参数取的名字。标识符不能是关键字或保留字。

#### 2.关键字

关键字 ∶ 是指 JS 本身已经使用了的字，不能再用它们充当变量名、方法名。
包括: break、case、catch、continue、default、delete、do、else、finally、for、function、if、in.instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。

#### 3.保留字

保留字︰实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。

包括: boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。

### 6.运算符

运算符( operator )也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。

JavaScript 中常用的运算符有 ∶

- 算数运算符
- 递增和递减运算符
- 比较运算符哈
- 逻辑运算符
- 赋值运算符

#### 1.算术运算符

y=5，下面的表格解释了这些算术运算符：

| 运算符 | 描述         | 例子   | x 运算结果 | y 运算结果 |
| :----- | :----------- | :----- | :--------- | :--------- |
| +      | 加法         | x=y+2  | 7          | 5          |
| -      | 减法         | x=y-2  | 3          | 5          |
| \*     | 乘法         | x=y\*2 | 10         | 5          |
| /      | 除法         | x=y/2  | 2.5        | 5          |
| %      | 取模（余数） | x=y%2  | 1          | 5          |
| ++     | 自增         | x=++y  | 6          | 6          |
| ++     | 后自增       | x=y++  | 5          | 6          |
| --     | 自减         | x=--y  | 4          | 4          |
| --     | 后自减       | x=y--  | 5          | 4          |

#### 2.比较运算符

| 运算符 | 描述                                               |
| :----- | :------------------------------------------------- |
| ==     | 等于                                               |
| ===    | 全等于（值和数据类型均相等）                       |
| !=     | 不等于                                             |
| !==    | 不绝对等于（值和类型有一个不相等，或两个都不相等） |
| >      | 大于                                               |
| <      | 小于                                               |
| >=     | 大于或等于                                         |
| <=     | 小于或等于                                         |

#### 3.逻辑运算符

| 运算符 | 描述      | 例子                      |
| :----- | :-------- | :------------------------ |
| &&     | and（且） | (x < 10 && y > 1) 为 true |
| \|\|   | or（或）  | (x==5 \|\| y==5) 为 false |
| !      | not（非） | !(x==y) 为 true           |

**短路运算（逻辑中断)**

短路运算的原理 ∶ 当有多个表达式(值)时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值; 1.逻辑与

```javascript
语法: 表达式1 && 表达式2 && 表达式3
```

- **小结**：返回 值为假的表达式，没有则返回最后一个

  2.逻辑或

```
语法:表达式1||表达式2||表达式3
```

**小结**：返回 值为真的表达式，没有则返回最后一个

#### 4.赋值运算符

给定 **x=10** 和 **y=5**，下面的表格解释了赋值运算符：

| 运算符 | 例子  | 等同于 | 运算结果 |
| :----- | :---- | :----- | :------- |
| =      | x=y   | x=y    | x=5      |
| +=     | x+=y  | x=x+y  | x=15     |
| -=     | x-=y  | x=x-y  | x=5      |
| \*=    | x\*=y | x=x\*y | x=50     |
| /=     | x/=y  | x=x/y  | x=2      |
| %=     | x%=y  | x=x%y  | x=0      |

#### 5.运算符优先级

| 优先级 | 运算符     | 顺序          |
| ------ | ---------- | ------------- |
| 1      | 小括号     | ()            |
| 2      | —元运算符  | ++ -- !       |
| 3      | 算数运算符 | 先\*/%后+-    |
| 4      | 关系运算符 | `>` >= < <=   |
| 5      | 相等运算符 | == != === !== |
| 6      | 逻辑运算符 | 先&&后\|\|    |
| 7      | 赋值运算符 | =             |
| 8      | 逗号运算符 | ,             |

- 一元运算符里面的逻辑非优先级很高
- 逻辑与比逻辑或优先级高

## 2.JavaScript 流程控制

### 1.流程控制

在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。
简单理解︰流程控制就是来控制我们的代码按照什么结构顺序来执行
流程控制主要有三种结构，分别是**顺序结构**、**分支结构**和**循环结构**，这三种结构代表三种代码执行的顺序。

### 2.顺序流程控制

顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。

### 3.分支流程控制 if 语句

#### 3.1 分支结构

由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果

#### 3.2 if 语句

1.语法结构

```javascript
//条件成立执行代码，否则什么也不做
if (条件表达式) {
  //条件成立执行的代码语句
}
```

语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下，会分割成一个一个的语句。

#### 3.3 if else 语句(双分支语句)

1.语法结构

```javascript
//条件成立执行if里面代码，否则执行else里面的代码
if (条件表达式) {
  //[如果]条件成立执行的代码
} else {
  //[否则]执行的代码
}
```

#### 3.4if else if 语句(多分支语句)

1.语法结构

```javascript
//适合于检查多重条件。
if(条件表达式1）{
	语句1;
} else if(条件表达式2){
	语句2;
}else if(条件表达式3){
	语句3;
} else {
//上述条件都不成立执行此处代码
}
```

#### 3.5 三元表达式

三元表达式也能做一些简单的条件选择。有三元运算符组成的式子称为三元表达式

语法：

```javascript
判断表达式 ? 表达式1 : 表达式2 //判断表达式为true返回表达式1;false返回表达式2
```

#### 3.6 分支流程控制 switch 语句

##### 3.6.1 语法结构

switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。

```javascript
 switch (表达式) {
     case value1:
         执行语句1;
         break;
     case value2:
         执行语句2;
         break;
         ...
     default:
     执行最后的语句;
 }
```

##### 3.6.2 switch 语句和 if else if 语句的区别

- 一般情况下，它们两个语句可以相互替换
- switch..case 语句通常处理 case 为比较确定值的情况，而 if..else...语句更加灵活，常用于范围判断(大于、
  等于某个范围)
- switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而 if..else 语句有几种条件，就得判断多
  少次。
- 当分支比较少时，if...else 语句的执行效率比 switch 语句高。
- 当分支比较多时，switch 语句的执行效率比较高，而且结构更清晰。

### 4.循环流程控制

#### 1.循环

循环目的：在实际问题中，有许多具有**规律性的重复操作**，因此在程序中要完成这这类操作就需要**重复执行某些语句**

在 Js 中，主要有三种类型的循环语句 ∶

- for 循环
- while 循环
- do...while 循环

#### 2.for 循环

在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称之为循环语句

**语法结构**

for 循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下 ∶

```javascript
for (初始化变量; 条件表达式; 操作表达式) {
  //循环体
}
```

**断点调试:**
断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。
**断点调试可以帮我们观察程序的运行过程**

- 浏览器中按 F12--> sources -->找到需要调试的文件-->在程序的某一行设置断点
- Watch:监视，通过 watch 可以监视变量的值的变化，非常的常用。
- F11:程序单步执行，让程序一行一行的执行，这个时候，观察 watch 中变量的值的变化。
- 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决 bug 的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。
- 今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。

#### 3.双重 for 循环

#### 双重 for 循环概述

很多情况下，单层 for 循环并不能满足我们的需求，比如我们要打印一个 5 行 5 列的图形、打印一个倒直角三角形等，此时就可以通过循环嵌套来实现。

**循环嵌套**是指在一个循环语句中再定义一个循环语句的语法结构，例如在 for 循环语句中，可以再嵌套一个 for 循环，这样的 for 循环语句我们称之为**双重 for 循环**。

#### for 循环小结

- for 循环可以重复执行某些相同代码
- for 循环可以重复执行些许不同的代码，因为我们有计数器
- for 循环可以重复执行某些操作，比如算术运算符加法操作
- 随着需求增加，双重 for 循环可以做更多、更好看的效果
- 双重 for 循环，外层循环一次，内层 for 循环全部执行
- for 循环是循环条件和数字直接相关的循环
- 分析要比写代码更重要
- 一些核心算法想不到，但是要学会，分析它执行过程
- 举一反三，自己经常总结，做一些相似的案例

#### 4.while 循环

while 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环 while 语句的语法结构如下 ∶

```javascript
while (条件表达式) {
  //循环体代码
}
```

**执行思路:**

- 先执行条件表达式，如果结果为 true，则执行循环体代码;
- 如果为 false，则退出循环，执行后面代码 ② 执行循环体代码
- 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为 true，则会继续执行循环体，直到循
  环条件为 false 时，整个循环过程才会结束

#### 5.do while 循环

do... while 语句其实是 while 语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环
do... while 语句的语法结构如下 ∶

```javascript
do {
  //循环体代码 – 条件表达式为 true 时重复执行循环体代码
} while (条件表达式)
```

**执行思路:**

- 先执行一次循环体代码

- 再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码

  **注意 ∶ 先再执行循环体，再判断，我们会发现 do...while 循环语句至少会执行一次循环体代码**

#### 6.循环小结

- JS 中循环有 for . while、do while
- 三个循环很多情况下都可以相互替代使用
- 如果是用来计次数，跟数字相关的，三者使用基本相同，但是我们更喜欢用 for
- while 和 do...while 可以做更复杂的判断条件，比 for 循环灵活一些
- while 和 do...while 执行顺序不一样，while 先判断后执行，do...while 先执行一次，再判断执行
- while 和 do...while 执行次数不一样，do...while 至少会执行一次循环体，而 while 可能一次也不执行
- 实际工作中，**我们更常用 for 循环语句**，它写法更简洁直观，所以这个要重点学习

#### 7.continue break

##### 7.1 continue 关键字

**continue 关键字**用于立即**跳出本次循环**，**继续下一次循环**（本次循环体中 continue 之后的代码就会少执行一次)。

##### 7.2 break 关键字

break 关键字用于立即跳出整个循环（循环结束)。

## 3.JavaScript 命名规范以及语法格式

### 1.标识符命名规范

- 变量、函数的命名必须要有意义
- 变量的名称一般用名词
- 函数的名称一般用动词

### 2.操作符规范

```javascript
//操作符的左右两侧各保留一个空格
for (var i = l; i <= 5; i++) {
  if (i == 3) {
    break //直接退出整个for循环，跳到整个for循环下面的语句
  }
  console.log('我正在吃第' + i + '个包子呢')
}
```

## 4.JavaScript 数组

### 1.数组大概念

> 数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。

### 2.创建数组

#### 2.1 数组的创建方式

JS 中创建数组有两种方式:

- 利用 new 创建数组
- 利用数组字面量创建数组

#### 2.2 利用 new 创建数组

```javascript
let arr = [1, 2, 3]
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
```

```javascript
var 数组名 = new Array()
var arr = new Array() //创建一个新的空数组
```

这种方式暂且了解，等学完对象再看注意 Array0 ，A 要大写

#### 2.3 利用数组字面量创建数组

```javascript
//1．使用数组字面量方式创建空的数组
var 数组名 = [] ;
//2．使用数组字面量方式创建带初始值的数组
var 数组名 =['小白'，小黑'，'大黄'，'瑞奇'];
```

- 数组的字面量是方括号[]
- 声明数组并赋值称为数组的初始化
- 这种字面量方式也是我们以后最多使用的方式

#### 2.4 数组元素的类型

数组中可以存放任意类型的数据，例字符串，数字，布尔值等。

```javascript
var arrstus = ['小白",12,true,28.9] ;
```

### 3.获取数组元素

#### 3.1 数组的索引

索引(下标)∶ 用来访问数组元素的序号（数组下标从 0 开始)。

vararr = ['小白','小黑','大黄','瑞奇'];
索引号 ∶ 0 1 2 3

数组可以通过**索引**来访问、设置、修改对应的数组元素，我们可以通过“**数组名[索引**”的形式来获取数组中的元素。
这里的**访问**就是获取得到的意思

```javascript
//定义数组
var arrstus = [1, 2, 3]
//获取数组中的第2个元素
alert(arrStus[1])
```

### 4.遍历数组

**遍历**:就是把数组中的每个元素从头到尾都访问一次(类似我们每天早上学生的点名)。

es6 语法：

```javascript
Array.forEach(item => {item.value = 1});

Array.every(item=>item.value)==>所有item.value都为true则返回true,否则返回false;

Array.some(item=>item.value)==>存在item.value为true则返回true,否则返回false;

Array.forEach((item, key) => { if (item === '指定元素') arrList.splice(key, 1) })

let newList= Array.filter( (item, index) =>item != '指定元素' )  ==>过滤掉不需要的
```

### 5.数组中新增元素

可以通过修改 length 长度以及索引号增加数组元素

#### 5.1 通过修改 length 长度新增数组元素

可以通过修改 length 长度来实现数组扩容的目的

```javascript
length属性是可读写的
var arr = ['red', 'green', 'blue', 'pink']
arr.length = 7
console.log(arr)
console.log(arr[4])
console.log(arr[5])
console.log(arr[6])
```

其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是**undefined**。

#### 5.2 通过修改数组索引新增数组元素

- 可以通过修改数组索引的方式追加数组元素
- 不能直接给数组名赋值，否则会覆盖掉以前的数据

```
var arr = [ 'red','green','blue','pink'];
arr[4] = 'hotpink';
console.log (arr);
```

这种方式也是我们最常用的一种方式。

### 6.数组排序

冒泡排序︰是一种算法，把一系列的数据按照一定的顺序进行排列显示(从小到大或从大到小)。

**冒泡排序**：是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺字错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 ° 浮"到数列的顶端。

![Snipaste_2021-02-10_13-40-00](../../../../../../figure/Snipaste_2021-02-10_13-40-00.png)

```javascript
/* 交换躺输为:i=length-1;交换次数为:j=length-i-1  */
let arr = [5, 4, 3, 2, 1]
for (let i = 0; i < arr.length - 1; i++) {
  // 外层循环管趟数
  for (let j = 0; j < arr.length - i - 1; j++) {
    // 里面的循环管 每一趟的交换次数
    // 内部交换2个变量的值 前一个和后面一个数组元素相比较
    if (arr[j] > arr[j + 1]) {
      let temp = arr[j]
      arr[j] = arr[j + 1]
      arr[j + 1] = temp
    }
  }
}
```

## 5.JavaScript 函数

### 1. 函数的概念

在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。 虽然 for 循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。 **函数**：就是**封装了一段可被重复调用执行的代码块**。通过此代码块可以实现大量代码的重复使用。

### 2. 函数的使用

#### 2.1 声明函数

函数在使用时分为两步：声明函数和调用函数。

```javascript
// 声明函数
function 函数名() {
  //函数体代码
}
```

- function 是声明函数的关键字,必须小写
- 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum

#### 2.2 调用函数

```javascript
// 调用函数
函数名() // 通过调用函数名来执行函数体代码
```

- 调用的时候千万不要忘记添加小括号
- 口诀：函数不调用，自己不执行。

注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。

#### 2.3 函数的封装

- 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口
- 简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）

### 3. 函数的参数

#### 3.1 形参和实参

在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。

| 参数 | 说明                                                                 |
| ---- | -------------------------------------------------------------------- |
| 形参 | **形**式上的**参**数 **函数定义**的时候传递的参数 当前并不知道是什么 |
| 实参 | **实**际上的**参**数 **函数调用**的时候传递的参数 实参是传递给形参的 |

**参数的作用** : 在**函数内部**某些值不能固定，我们可以通过参数在**调用函数时传递**不同的值进去。

在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为**形参**，而在调用该函数时，同样也需要传递相应的参数，这些参数被称为**实参**。

```javascript
// 带参数的函数声明
function 函数名(形参1, 形参2 , 形参3...) {
// 可以定义任意多的参数，用逗号分隔
// 函数体
 }
 // 带参数的函数调用
 函数名(实参1, 实参2, 实参3...);
```

#### 3.2 函数参数的传递过程

```javascript
// 声明函数
function getSum(num1, num2) {
  console.log(num1 + num2)
}
// 调用函数
getSum(1, 3) // 4
getSum(6, 5) // 11
```

1. 调用的时候实参值是传递给形参的
2. 形参简单理解为：**不用声明的变量**
3. 实参和形参的多个参数之间用逗号（,）分隔

#### 3.3 函数形参和实参个数不匹配问题

| 参数个数             | 说明                                 |
| -------------------- | ------------------------------------ |
| 实参个数等于形参个数 | 输出正确结果                         |
| 实参个数大于形参个数 | 只取到形参的个数                     |
| 实参个数小于形参个数 | 多的形参定义为 undefined，结果为 NaN |

```javascript
function sum(num1, num2) {
  console.log(num1 + num2)
}
sum(100, 200) // 形参和实参个数相等，输出正确结果 sum(100,  400, 500, 700);  // 实参个数多于形参，只取到形参的个数
sum(200) // 实参个数少于形参，多的形参定义为undefined，结果为NaN
```

#### 3.4 小结

- 函数可以带参数也可以不带参数
- 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined
- 调用函数的时候，函数名括号里面的是实参
- 多个参数中间用逗号分隔
- 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配

### 4.函数的返回值

#### 4.1 return 语句

有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。

return 语句的语法格式如下：

```javascript
// 声明函数
function 函数名（）{  ... return 需要返回的值;}
// 调用函数
函数名();
// 此时调用函数就可以得到函数体内return 后面的值
```

- 在使用 return 语句时，函数会停止执行，并返回指定的值
- 如果函数**没有 return** ，返回的值是 **undefined**

有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。

例如，声明了一个 sum()函数，该函数的返回值为 666，其代码如下：

```javascript
// 声明函数
function sum（）{   ...    return 666;}
// 调用函数
sum(); // 此时 sum 的值就等于666，因为 return  语句会把自身后面的值返回给调用者
```

#### 4.2 return 终止函数

return 语句之后的代码不被执行。

```javascript
function add(num1，num2){   //函数体
  return num1 + num2; // 注意：return 后的代码不执行
    alert('我不会被执行，因为前面有 return');
}
var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值
alert(resNum);     // 27
```

#### 4.3 return 的返回值

return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准。

```javascript
function  add(num1，num2){
    //函数体
    return num1，num2;
}
var resNum =  add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值  alert(resNum);     // 6
```

#### 4.4 函数没有 return 返回 undefined

函数都是有返回值的

1. 如果有 return 则返回 return 后面的值

2. 如果没有 return 则返回 undefined

#### 4.5 break ,continue ,return 的区别

- break ：结束当前的循环体（如 for、while）
- continue ：跳出本次循环，继续执行下次循环（如 for、while）
- return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码

### 5. arguments 的使用

当我们不确定有多少个参数传递的时候，可以用 **arguments** 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个**内置对象**。所有函数都内置了一个 arguments 对象，arguments 对象中存**储了传递的所有实参**。

**arguments 展示形式是一个伪数组**，因此可以进行遍历。伪数组具有以下特点：

- 具有 length 属性
- 按索引方式储存数据
- 不具有数组的 push , pop 等方法

### 6.函数的两种声明方式

#### 1.自定义函数方式(命名函数)

利用函数关键字 function 自定义函数方式。

```javascript
// 声明定义方式
function  fn() {...}
// 调用
fn();
```

- 因为有名字，所以也被称为**命名函数**
- 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面

#### 2.函数表达式方式(匿名函数）

利用函数表达式方式的写法如下：

```javascript
// 这是函数表达式写法，匿名函数后面跟分号结束
var fn = function(){...}；
// 调用的方式，函数调用必须写到函数体下面
fn();
```

- 因为函数没有名字，所以也被称为匿名函数
- 这个 fn 里面存储的是一个函数
- 函数表达式方式原理跟声明变量方式是一致的
- 函数调用的代码必须写到函数体后面

## 6.JavaScript 作用域

### 1.作用域

#### 1.1 作用域概述

通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

### 2.变量的作用域

#### 2.1 变量作用域的分类

在 JavaScript 中，根据作用域的不同，变量可以分为两种:

- 全局变量
- 局部变量

#### 2.2 全局变量

在全局作用域下声明的变量叫做全局变量(在函数外部定义的变量)。.

- 全局变量在代码的任何位置都可以使用
- 在全局作用域下 var 声明的变量是全局变量
- 特殊情况下，在函数内不使用 var 声明的变量也是全局变量(不建议使用)

#### 2.3 局部变量

在局部作用域下声明的变量叫做局部变量(在函数内部定义的变量)

- 局部变量只能在该函数内部使用
- 在函数内部 var 声明的变量是局部变量
- 函数的**形参**实际上就是局部变量

#### 2.3 全局变量和局部变量的区别

- 全局变量:在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存
- 局部变量︰只在函数内部使用，当其所在的代码块被执行时，会被初始化;当代码块运行结束后，就会被销毁，因此更节省内存空间

### 3.作用域链

- 只要是代码，就至少有一个作用域
- 写在函数内部的局部作用域
- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
- 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链

## 7.JavaScript 预解析

### 1.预解析

JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步 ∶ 预解析和代码执行。

1. 我们 js 引擎运行 js 分为两步：预解析代码执行

   - 预解析 js 引擎会把 js 里面所有的 var 还有 function 提升到当前作用域的最前面
   - 代码执行 按照代码书写的顺序从上往下执行

2. 预解析分为 变量预解析（变量提升）和 函数预解析（函数提升）
   - 变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作
   - 函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数

## 8.JavaScript 对象

### 1.对象

#### 1.1 什么是对象?

在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。

对象是由属性和方法组成的。

- 属性 ∶ 事物的**特征**，在对象中用**属性**来表示(常用名词)
- 方法︰事物的**行为**，在对象中用**方法**来表示(常用动词)

#### 1.2 为什么需要对象

保存一个值时，可以使用**变量**，保存多个值(一组值)时，可以使用**数组**。如果要保存一个人的完整信例如，将“张三疯”的个人的信息保存在数组中的方式为︰

```javascript
var arr =[ '张三疯，'男'，128,154] ;
```

JS 中的对象表达结构更清晰，更强大。张三疯的个人信息在对象中的表达结构如下 ∶

```javascript
张三疯.姓名 = '张三疯'
张三疯.性别 = '男'
张三疯.年龄 = 128
张三疯.身高 = 154
```

```javascript
person.name = '张三疯' //或者person['name']='张三疯'
person.sex = '男'
person.age = 128
person.height = 154
```

```javascript
//删除指定元素
delete Object[key]
```

### 2.创建对象的三种方式

在 JavaScript 中，现阶段我们可以采用三种方式创建对象( object ) :

- 利用**字面量**创建对象

- 利用**new Object**创建对象
- 利用**构造函数**创建对象

#### 2.1 利用字面量创建对象

对象字面量:就是花括号{}里面包含了表达这个具体事物（对象）的属性和方法。

**变量、属性、函数、方法总结**

- 变量:单独声明赋值，单独存在
- 属性:对象里面的变量称为属性，不需要声明，用来描述该对象的特征
- 函数︰单独存在的，通过“函数名()”的方式就可以调用
- 方法 ∶ 对象里面的函数称为方法，方法不需要声明，使用“对象.方法名(”的方式就可以调用，方法用来描述该对象的行为和功能。

#### 2.2 利用 new Object 创建对象

跟我们前面学的 new Array)原理一致

#### 2.3 利用构造函数创建对象

**构造函数** ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起 使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。

在 js 中，使用构造函数要时要注意以下两点：

- 构造函数用于创建某一类对象，其**首字母要大写**
- 构造函数要**和 new 一起使用**才有意义

```javascript
function Star(uname, age, sex) {
  this.name = uname
  this.age = age
  this.sex = sex
  this.sing = function (sang) {
    console.log(sang)
  }
}
var ldh = new Star('刘德华', 18, '男') // 调用函数返回的是一个对象
```

注意

1. 构造函数约定首字母大写。

2. 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。
3. 构造函数中不需要 return 返回结果。
4. 当我们创建对象的时候，必须用 new 来调用构造函数。

#### 2.4 构造函数和对象

- 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）
- 创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化

### 3.new 关键字

new 在执行时会做四件事情:

1. 在内存中创建一个新的空对象。

2. 让 this 指向这个新的对象。

3. 执行构造函数里面的代码，给这个新对象添加属性和方法。

4. 返回这个新对象（所以构造函数里面不需要 return ) 。

### 4. 遍历对象属性

for...in 语句用于对数组或者对象的属性进行循环操作。 其语法如下：

```javascript
for (变量 in 对象名字) {
  // 在此执行代码
}
```

语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。

```javascript
for (var k in obj) {
  console.log(k) // 这里的 k 是属性名
  console.log(obj[k]) // 这里的 obj[k] 是属性值
}
```

**小结**

1. 对象可以让代码结构更清晰
2. 对象复杂数据类型 object。
3. 本质：对象就是一组无序的相关属性和方法的集合。
4. 构造函数泛指某一大类，比如苹果，不管是红色苹果还是绿色苹果，都统称为苹果。
5. 对象实例特指一个事物，比如这个苹果、正在给你们讲课的 pink 老师等。
6. for...in 语句用于对对象的属性进行循环操作。

## 9.JavaScript 内置对象

### 1.内置对象

- JavaScript 中的对象分为 3 种:自定义对象、内置对象、浏览器对象
- 前面两种对象是 JS 基础内容，属于 ECMAScript;第三个浏览器对象属于我们 S 独有的，我们 JS API 讲解
- 内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法)
- 内置对象最大的优点就是帮助我们快速开发
- JavaScript 提供了多个内置对象:Math、 Date . Array、string 等

```javascript
//去除两边空格
trim()
//切割字符串
slice()
let str='index.js';	console.log(str.slice(-3)))==>'.js'
```

### 2. 查文档

#### 2.1 MDN

学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过 MDN/W3C 来查询。

Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。

MDN: https://developer.mozilla.org/zh-CN/

#### 2.2 如何学习对象中的方法

1. 查阅该方法的功能

2. 查看里面参数的意义和类型
3. 查看返回值的意义和类型
4. 通过 demo 进行测试

### 3. Math 对象

#### 3.1 Math 概述

Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值 等）可以使用 Math 中的成员。

```javascript
Math.PI // 圆周率
Math.floor() // 向下取整
Math.ceil() // 向上取整
Math.round() // 四舍五入版 就近取整 注意 -3.5 结果是 -3
Math.abs() // 绝对值
Math.max() / Math.min() // 求最大和最小值
```

**注意：上面的方法必须带括号**

#### 3.2 随机数方法 random()

random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 <= x < 1 得到一个两数之间的随机整数，包括两个数在内

```javascript
function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}
```

生成 length 个 0~9 的随机数:

```javascript
function random(length) {
  let result = ''
  for (let i = 0; i < length; i++) {
    let index = Math.floor(Math.random() * 10)
    result += index
  }
  return result
}
```

### 4. 日期对象

#### 4.1 Date 概述

- Date 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用
- Date 实例用来处理日期和时间

#### 4.2 Date()方法的使用

**1.获取当前时间必须实例化**

```javascript
var now = new Date()
console.log(now)
```

**2.Date(构造函数的参数**
如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为‘2019-5-1’，可以写成 new Date(2019-5-1")或者 new Date(2019/5/1)

#### 4.3 日期格式化

| 方法名        | 说明                        | 代码               |
| ------------- | --------------------------- | ------------------ |
| getFullYear() | 获取当年                    | dObj.getFullYear() |
| getMonth()    | 获取当月(0-11)              | dObj.getMonth()    |
| getDate()     | 获取当天日期                | dObj.getDate()     |
| getDay()      | 获取星期几(周日 0 到周六 6) | dobj.getDay()      |
| getHours()    | 获取当前小时                | dobj.getHours()    |
| getMinutes()  | 获取当前分钟                | dObj.getMinutes()  |
| getSeconds()  | 获取当前秒钟                | dObj.getSeconds()  |

#### 4.4 获取日期的总的毫秒形式 (时间戳)

Date 对象是基于 1970 年 1 月 1 日（世界标准时间）起的毫秒数

为什么计算机起始时间从 1970 年开始? 我们经常利用总的毫秒数来计算时间，因为它更精确

```javascript
// 实例化Date对象
var now = new Date()
// 1. 用于获取对象的原始值
console.log(date.valueOf())
console.log(date.getTime())
// 2. 简单写可以这么做
var now = +new Date()
// 3. HTML5中提供的方法，有兼容性问题
var now = Date.now()
```

**小结代码：**

```javascript
/* 生成系统当前时间 */
function createTime() {
  const date = new Date() //创建时间对象
  const yy = date.getFullYear() //年
  const MM = (date.getMonth() + 1 + '').padStart(2, '0') //月(padStart:字符串不满2位数,开头补全'0')
  const dd = (date.getDate() + '').padStart(2, '0') //日
  const hh = (date.getHours() + '').padStart(2, '0') //小时
  const mm = (date.getMinutes() + '').padStart(2, '0') //分钟
  const ss = (date.getSeconds() + '').padStart(2, '0') //秒钟
  return `${yy}-${MM}-${dd} ${hh}:${mm}:${ss}` //返回时间
}
/* 转换时间戳 */
function getTimes(time) {
  const date = +new Date(time)
  // const date1 = Date.now()//H5当前时间戳
  // console.log(date1)
  return date
}
/* 格式化时间 */
function formatTime(time) {
  /* 格式化的时间戳必须是Number型*/
  const date = new Date(time) //创建时间对象
  const yy = date.getFullYear() //年
  const MM = (date.getMonth() + 1 + '').padStart(2, '0') //月
  const dd = (date.getDate() + '').padStart(2, '0') //日
  const hh = (date.getHours() + '').padStart(2, '0') //小时
  const mm = (date.getMinutes() + '').padStart(2, '0') //分钟
  const ss = (date.getSeconds() + '').padStart(2, '0') //秒钟
  return `${yy}-${MM}-${dd} ${hh}:${mm}:${ss}` //返回时间
}
/* 倒计时 */
function countDown(time) {
  var nowTime = +new Date() // 当前时间戳
  var endTime = +new Date(time) // 结束时间戳
  var times = (endTime - nowTime) / 1000 // 剩余时间总的秒数
  var dd = parseInt(times / 60 / 60 / 24)
    .toString()
    .padStart(2, '0') // 天
  var hh = parseInt(((times / 60 / 60) % 24) + '')
    .toString()
    .padStart(2, '0') //时
  var mm = parseInt(((times / 60) % 60) + '')
    .toString()
    .padStart(2, '0') // 分
  var ss = parseInt((times % 60) + '')
    .toString()
    .padStart(2, '0') // 当前的秒
  return `${dd}天${hh}时${mm}分${ss}秒` //返回时间
}
console.log('系统当前时间:', createTime())
console.log('时间戳:', getTimes(createTime()))
console.log('转换时间戳:', getTimes('2021-03-01 08:00:00'))
console.log('格式化指定时间:', formatTime(getTimes('2021-03-01 08:00:00')))
console.log('格式化当前时间:', formatTime(getTimes(createTime())))
console.log('倒计时:', countDown('2021-02-13 08:00:00'))
```

### 5. 数组对象

#### 5.1 数组对象的创建

创建数组对象的两种方式

- 字面量方式
- new Array()

#### 5.2 检测是否为数组

- instanceof 运算符，可以判断一个对象是否属于某种类型
- Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法

```javascript
var arr = [1, 23]
var obj = {}
console.log(arr instanceof Array) // true
console.log(obj instanceof Array) // false
console.log(Array.isArray(arr)) // true
console.log(Array.isArray(obj)) // false
```

#### 5.3 添加删除数组元素的方法

| 方法名             | 说明                                                    | 返回值               |
| ------------------ | ------------------------------------------------------- | -------------------- |
| push(参数 1....)   | 末尾添加一个或多个元素，注意修改原数组                  | 并返回新的长度       |
| pop()              | 删除数组最后一个元素，把数组长度减 1 无参数、修改原数组 | 返回它删除的元素的值 |
| unshift(参数 1...) | 向数组的开头添加一个或更多元素，注意修改原数组          | 并返回新的长度       |
| shift()            | 删除数组的第一个元素，数组长度减 1 无参数、修改原数组   | 返回它删除的元素的值 |
| splice(index,num)  | 删除指定元素：index 第几个开始，num 为删除个数          | 返回它删除的元素的值 |

#### 5.4 数组排序

| 方法名    | 说明                        | 是否修改原数组                   |
| --------- | --------------------------- | -------------------------------- |
| reverse() | 颠倒数组中元素的顺序,无参数 | 该方法会改变原来的数组返回新数组 |
| sort()    | 对数组的元素进行排序        | 该方法会改变原来的数组返回新数组 |

```javascript
var arr = [1, 64, 9, 6]
arr.sort(function (a, b) {
  return b - a // 降a序
  // return a - b; // 升序
})
console.log(arr)
```

#### 5.5 数组索引方法

| 方法名        | 说明                           | 返回值                                   |
| ------------- | ------------------------------ | ---------------------------------------- |
| indexOf()     | 数组中查找给定元素的第一个索引 | 如果存在返回索引号如果不存在，则返回-1。 |
| lastIndexOf() | 在数组中的最后一个的索引,      | 如果存在返回索引号如果不存在，则返回-1。 |

**封装数组去重复**

```javascript
// 封装一个 去重的函数 unique 独一无二的
function unique(arr) {
  let newArr = []
  for (let i = 0; i < arr.length; i++) {
    if (newArr.indexOf(arr[i]) === -1) {
      newArr.push(arr[i])
    }
  }
  return newArr
}
```

#### 5.6 数组转换为字符串

| 方法名         | 说明                                         | 返回值         |
| -------------- | -------------------------------------------- | -------------- |
| toString()     | 把数组转换成字符串，逗号分隔每一项           | 返回一个字符串 |
| join("分隔符') | 方法用于把数组中的所有元素转换为一个字符串。 | 返回一个字符串 |

#### 5.7 其他方法

| 方法名   | 说明                                                          | 返回值                                 |
| -------- | ------------------------------------------------------------- | -------------------------------------- |
| concat() | 连接两个或多个数组不影响原数组                                | 返回一个新的数组                       |
| slice()  | 数组截取 slice(begin, end),包括 begin 不包括 end,不影响原数组 | 返回被截取项目的新数组                 |
| splice() | 数组删除 splice(第几个开始,要删除个数)                        | 返回它删除的元素的值，这个会影响原数组 |

slice() 和 splice() 目的基本相同，建议同学们重点看下 splice()

### 6.字符串对象

#### 6.1 基本包装类型

为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number 和 Boolean。 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。

```javascript
// 下面代码有什么问题？
var str = 'andy'
console.log(str.length)
```

按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把 基本数据类型包装为复杂数据类型，其执行过程如下 ：

```javascript
// 1. 生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy')
// 2. 赋值给我们声明的字符变量
str = temp
// 3. 销毁临时变量
temp = null
```

#### 6.2 字符串的不可变

指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。

```javascript
var str = 'abc'
str = 'hello'
// 当重新给 str 赋值的时候，常量'abc'不会被修改，依然在内存中
// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变
// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题
var str = ''
for (var i = 0; i < 100000; i++) {
  str += i
}
console.log(str) // 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间
```

#### 6.3 根据字符返回位

字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串。

| 方法名                               | 说明                                                                          |
| ------------------------------------ | ----------------------------------------------------------------------------- |
| indexOf('要查找的字符，[开始的位置]) | 返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是 index 索引号 |
| lastIndexOf()                        | 从后往前找，只找第一个匹配的                                                  |

#### 6.4 根据位置返回字符（重点）

| 方法名            | 说明                                        | 使用                           |
| ----------------- | ------------------------------------------- | ------------------------------ |
| charAt(index)     | 返回指定位置的字符(index 字符串的索引号)    | str.charAt(O)                  |
| charCodeAt(index) | 获取指定位置处字符的 ASCII 码(index 索引号) | str.charCodeAt(O)              |
| str[index]        | 获取指定位置处字符                          | HTML5，IE8+支持和 charAt()等效 |

#### 6.5 字符串操作方法（重点）

| 方法名                    | 说明                                                              | 返回值                       |
| ------------------------- | ----------------------------------------------------------------- | ---------------------------- |
| concat(str1,str2,str3...) | 用于连接两个或多个字符串。拼接字符串，等效于+，+更常用            | 返回新字符串                 |
| substr(start,length)      | 从 start 位置开始, length 取的个数重点记住这个                    | 返回截取部分，不影响原字符串 |
| slice(start, end)         | 从 start 位置开始，截取到 end 位置，end 取不到(他们俩都是索引号） | 返回截取部分，不影响原字符串 |
| substring(start, end)     | 基本和 slice 相同，但是不接受负值                                 | 返回截取部分，不影响原字符串 |

#### 6.6replace()方法

replace() 方法用于在字符串中用一些字符替换另一些字符。 其使用格式如下：

```javascript
 replace(被替换的字符串， 要替换为的字符串);//只替换第一个相同的字符
```

#### 6.7split()方法

split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。 例如下面代码：

```javascript
var str = 'a,b,c,d'
console.log(str.split(',')) // 返回的是一个数组 [a, b, c, d]
```

#### 6.8 其他方法

- toUpperCase() //转换大写
- toLowerCase() //转换小写

示例：

```javascript
let str8 = 'chenzhifeng'
let str9 = str8.toUpperCase() //转换为大写
let str10 = str9.toLowerCase() //转换为小写
console.log(str8, str9, str10)
```

## 10.JavaScript 简单类型与复杂类型

### 1.简单类型与复杂类型

简单类型又叫做基本数据类型或者**值类型**，复杂类型又叫做**引用类型**。

- 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型 string ，number，boolean，undefined，null
- 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型 通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等

### 2.堆和栈

堆栈空间分配区别：

1. 栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；

   **简单数据类型存放到栈里面**

2. 堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。

   **复杂数据类型存放到堆里面**

**注意**：JavaScript 中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言。

### 3.简单类型的内存分配

- 值类型（简单数据类型）： string ，number，boolean，undefined，null
- 值类型变量的数据直接存放在变量（栈空间）中

### 4. 复杂类型的内存分配

- 引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等
- 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中

### 5.简单类型传参

函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈 空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。

```javascript
function fn(a) {
  a++
  console.log(a)
}
var x = 10
fn(x)
console.log(x)
```

### 6. 复杂类型传参

函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地 址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。

```javascript
function Person(name) {
  this.name = name
}
function f1(x) {
  // x = p
  console.log(x.name) // 2. 这个输出什么 ?
  x.name = '张学友'
  console.log(x.name) // 3. 这个输出什么 ?
}
var p = new Person('刘德华')
console.log(p.name) // 1. 这个输出什么 ?
f1(p)
console.log(p.name) // 4. 这个输出什么 ?
```
