---
title: 1.js面向对象编程
date: 2023-06-02 13:56:09
categories:
  - 前端开发
tags:
  - javascript
  - js进阶
prev: ../js基础/6.本地存储
next: 2.js函数进阶
---

## 1. 面向对象编程介绍

### 1.1 两大编程思想

- 面向过程
- 面向对象

### 1.2 面向过程编程 POP(Process-oriented programming)

**面向过程**就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。

举个栗子：将大象装进冰箱，面向过程做法。

**面向过程，就是按照我们分析好了的步骤，按照步骤解决问题。**

### 1.3 面向对象编程 OOP (Object Oriented Programming)

**面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。**

举个栗子：将大象装进冰箱，面向对象做法。
先找出对象，并写出这些对象的功能：

1.  大象对象  
    进去
2.  冰箱对象
    打开
    关闭

3.  使用大象和冰箱的功能

面向对象是以对象功能来划分问题，而不是步骤。

在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。
面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。

面向对象的特性：

- 封装性
- 继承性
- 多态性

### 1.4 面向过程和面向对象的对比

**面向过程**

- 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。
- 缺点：没有面向对象易维护、易复用、易扩展

**面向对象**

- 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
- 缺点：性能比面向过程低

用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。

## 2. 构造函数和原型

### 2.1 概述

在典型的 OOP 的语言中（如 Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在 ES6 之前， JS 中并没用引入类的概念。
ES6， 全称 ECMAScript 6.0 ，2015.06 发版。但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。
在 ES6 之前 ，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。

创建对象可以通过以下三种方式：

1. 对象字面量
2. new Object()
3. 自定义构造函数

### 2.2 构造函数

**构造函数**是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。

在 JS 中，使用构造函数时要注意以下两点：

1. 构造函数用于创建某一类对象，其**首字母要大写**
2. 构造函数要**和 new 一起使用**才有意义

new 在执行时会做四件事情：

1. 在内存中创建一个新的空对象。
2. 让 this 指向这个新的对象。
3. 执行构造函数里面的代码，给这个新对象添加属性和方法。
4. 返回这个新对象（所以构造函数里面不需要 return ）。

JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为**静态成员**和**实例成员**。

**静态成员**：在构造函数本上添加的成员称为**静态成员，只能由构造函数本身来访问**
**实例成员**：在构造函数内部创建的对象成员称为**实例成员，只能由实例化的对象来访问**

### 2.3 构造函数的问题

构造函数方法很好用，但是存在浪费内存的问题。

```javascript
function Star(uname, age) {
  this.uname = uname
  this.age = age
  this.sing = function () {
    console.log('我会唱歌')
  }
}
var ldh = new Star('刘德华', 18)
var zxy = new Star('张学友', 19)
```

我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？

### 2.4 构造函数原型 prototype

构造函数通过原型分配的函数是所有对象所**共享的**。

JavaScript 规定，**每一个构造函数都有一个 prototype 属性**，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。

**我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。**

1. 原型是什么 ？
   一个对象，我们也称为 prototype 为原型对象。
2. 原型的作用是什么 ？
   共享方法。

### 2.5 对象原型 `__proto__`

对象都会有一个属性 `__proto__`指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 `__proto__`原型的存在。

- `__proto__`对象原型和原型对象 prototype 是等价的

- `__proto__`对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype

![image-20210222144845933](../../../../../../figure/image-20210222144845933.png)

### 2.6 constructor 构造函数

**对象原型（ `__proto__`）**和**构造函数（prototype）原型对象**里面都有一个属性 **constructor** 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。

constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。

**一般情况下，对象的方法都在构造函数的原型对象中设置**。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。

### 2.7 构造函数、实例、原型对象三者之间的关系

![image-20210222145110123](../../../../../../figure/image-20210222145110123.png)

### 2.8 原型链

![image-20210222145216551](../../../../../../figure/image-20210222145216551.png)

### 2.9 JavaScript 的成员查找机制(规则)

1. 当访问一个对象的属性（包括方法）时，首先查找这个**对象自身**有没有该属性。
2. 如果没有就查找它的原型（也就是 `__proto__`指向的 **prototype 原型对象**）。
3. 如果还没有就查找原型对象的原型（**Object 的原型对象**）。
4. 依此类推一直找到 Object 为止（**null**）。
5. `__proto__`对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。

#### 2.10 原型对象 this 指向

构造函数中的 this 指向我们实例对象.
**原型对象**里面放的是方法, 这个方法**里面的 this 指向**的是 这个方法的调用者, 也就是这个**实例对象**.

### 2.11 扩展内置对象

可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。

**注意**：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。

## 3. ES6 之前的继承

ES6 之前并没有给我们提供 extends 继承。我们可以通过**构造函数+原型对象**模拟实现继承，被称为**组合继承**。

### 3.1 call()

调用这个函数, 并且修改函数运行时的 this 指向

```
fun.call(thisArg, arg1, arg2, ...)
```

- thisArg ：当前调用函数 this 的指向对象
- arg1，arg2：传递的其他参数

### 3.2 借用构造函数继承父类型属性

核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。

```javascript
// 父类
function Person(name, age, sex) {
  this.name = name
  this.age = age
  this.sex = sex
}
// 子类
function Student(name, age, sex, score) {
  Person.call(this, name, age, sex) // 此时父类的 this 指向子类的 this，同时调用这个函数
  this.score = score
}
var s1 = new Student('zs', 18, '男', 100)
console.dir(s1)
```

### 3.3 借用原型对象继承父类型方法

**一般情况下**，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。  
 **核心原理**：

1. 将子类所共享的方法提取出来，让子类的 **prototype 原型对象 = new 父类()**
2. 本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象
3. 将子类的 constructor 从新指向子类的构造函数
