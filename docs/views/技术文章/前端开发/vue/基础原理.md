---
title: vue基础原理
date: 2023-06-01 15:07:25
categories:
  - 前端开发
tags:
  - vue
---

## 单页应用(SPA)

可以构建 SPA 应用的,并且比较热门的框架有三个，React,Vue,Angular,当然他们也可以构建 MPA 应用

SPA 的核心概念包括两个方面:数据传递和页面切换,页面切换一般指的是路由，包括路由的配置,跳转和监听，数据传递又可以分为组件内传递【单向数据流,双向数据绑定），组件之间传递【组件属性,回调事件，全局状态)，以及页面之间传递（路由参数，公共缓存）

## MVVM

MVVM 的实现主要是三个核心点:

- 响应式:vue 如何监听 data 的属性变化
- 模板解析:vue 的模板是如何被解析的
- 宣染:vue 模板是如何被渲染成 HTML 的

## data 为什么是函数

如果组件中的 data 不是一个函数,首先 vue 会报错,因为它内部规范组件中的 data 必须是一个函数。我们让 data 成为一个函数,且返回的是一个未定义对象,这样子就不会和上面返回是一个在全局作用域定义的对象,造成数据共享。因为此时我们每一次返回的对象的地址是不一样的,所以在组件对值进行修改的时候,会寻找对应组件的 data 返回对象的地址,这样子就能很好的控制组件数据独立了。

## v-model 的原理

v-model 是:value="msg"@input="msg=$event.target.value"的语法糖,其中:value="msg"是绑定了数据,value就是inpuit输入框里的值;input="msg=$event.target.value"就是监听 input 输入框里值的变化，然后改变值。一句话概括就是,**绑定数据并且监听数据改变**。

## Vue 的响应式原理(双向数据绑定)

1. 实现一个监听器 Observer,用来劫持并监听所有属性,如果有变动的,就通知订阅者。
2. 实现一个订词者 Watcher,可以收到属性的变 L 通知并执行相应的函数,从而更新视图。
3. 实现一个解析器 Compile,可以扫描和解析每个节点的相关指令,并根据初始化模板数据以及初始化相应的订询器。

## V-if 和 v-show 的区别

1. 实现本质方法区别
   - v-show 本质就是标签 display 设置为 none,控制隐藏
   - v-if 是动态的向 DOM 内添加或者删除 DOM 元素
2. 编译的区别
   - v-show 其实就是在控制 css
   - v-i 子切换有一个局部编译/卸载的过程,切换过程中合适地销毁和重建内部的事件监听和子组件
3. 编译的条件
   - v-show 都会编译,初始值为 false,只是游 display 设为 none,但它也编译了
   - v-if 初始值为 false,就不会编译了
4. 性能
   v-show 只编译一次,后面其实就是控制 css,而 v-if 不停的销毁和创建,故 v-show 性能更好一点。

## comeputed、watch 和 methods

### computed 与 methods 的区别

- computed 是响应式的,methods 并非响应式。
- 调用方式不一样,computed 定义的成员像属性一样访问，methods 定义的成员必须以函数形式调用。
- computed 是带缓存的,只有其引用的响应式属性发生改变时中会重新计算,而 methods 里的函数在每次调用时都要执行。

- computed 中的成员可以只定义一个函数作为只读属性,也可以定义 get/set 变成可读写属性,这点是 methods 中的成员做不到的

### computed 属性和 watch 区别

- computed 里属性名是自定义的,它可以监听一个或多个它所依赖的数据项;而 watch 一次只能监听一个属性,这个属性函数接收两个参数,一个是新值一个是旧值。
- computed 里自定义的属性**不能与 data 里的属性重复**,否则会报错;而 watch 里监听的属性必须是已存在的,其要么是 data 里的属性,要么是 computed 里计算出来的属性。
- watch 是允许异步操作的(访问一个 API),并在我们得到最络结果前,设置中间状态。这些都是计算属性无法做到的。

## Vue 的生金周期

在 new Vue()的对象过程当中,首先执行了 init ( init 是 vue 组件里面默认去执行的）,在 init 的过程当中首先调用了 beforeCreate,然后在 injections(注射）和 reactivity(反应性）的时候,它
会再去调用 created。

所以在 init 的时候,事件已经调用了,我们在 beforeCreate 的时候千万不要去修改 data 里面赋值的数据,最早也要放在 created 里面去做(添加一些行为)。

当 created 完成之后,它会去判断 instance(实例)里面是否含有“el" option(选项）,如果没有的话,它会调用 vm.Smount(el)这个方法,然后执行下一步;如果有的话，直接执行下一步。

紧接着会判断是否含有“template”这个选项,如果有的话,它会把 template 解析成一个 render function,这是一个 template 编译的过程,结果是解析新成了 render 函数。

## Vue 组件间通信的访式

1. props/$emit 方法
2. $emit/$on
3. vuex
4. $attrs/$listeners
5. provide/inject

## 父子组件生命周期顺序

父组件 beforeCreate(创建前)->父组件 created(创建后)->父组件 beforeMount(挂载前)->子组件 beforeCreate->千组件 created->子组件 beforeMount->子组件 mounted(挂载后)->父组件 mounted
