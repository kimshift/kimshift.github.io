import{_ as t,q as e,p as a,aE as l}from"./chunks/framework.-H45_L2h.js";const u=JSON.parse('{"title":"5.flex弹性布局","description":"","frontmatter":{"title":"5.flex弹性布局","date":"2023-06-02T09:59:15.000Z","categories":["前端开发"],"tags":["html"],"prev":"4.流式布局","next":"6.rem适配布局"},"headers":[],"relativePath":"技术文章/前端开发/html/5.flex弹性布局.md","filePath":"技术文章/前端开发/html/5.flex弹性布局.md","lastUpdated":1723096133000}'),i={name:"技术文章/前端开发/html/5.flex弹性布局.md"},s=l(`<h1 id="_5-flex-弹性布局" tabindex="-1">5.flex 弹性布局 <a class="header-anchor" href="#_5-flex-弹性布局" aria-label="Permalink to &quot;5.flex 弹性布局&quot;">​</a></h1><h2 id="_1-传统布局与-flex-布局" tabindex="-1">1.传统布局与 flex 布局 <a class="header-anchor" href="#_1-传统布局与-flex-布局" aria-label="Permalink to &quot;1.传统布局与 flex 布局&quot;">​</a></h2><p><strong>传统布局</strong></p><ul><li>兼容性好布局繁琐</li><li>局限性，不能再移动端很好的布局</li><li>局限性，不能再移动端很好的布局</li></ul><p><strong>flex 弹性布局</strong></p><ul><li>操作方便，布局极为简单，移动端应用很广泛 PC 端浏览器支持情况较差</li><li>IE11 或更低版本，不支持或仅部分支持</li></ul><p>建议 ∶</p><ol><li>如果是 PC 端页面布局，我们还是传统布局。</li><li>如果是移动端或者不考虑兼容性问题的 PC 端页面布局，我们还是使用 flex 弹性布局</li></ol><h2 id="_2-flex-布局原理" tabindex="-1">2.flex 布局原理 <a class="header-anchor" href="#_2-flex-布局原理" aria-label="Permalink to &quot;2.flex 布局原理&quot;">​</a></h2><h3 id="_2-1-布局原理" tabindex="-1">2.1 布局原理 <a class="header-anchor" href="#_2-1-布局原理" aria-label="Permalink to &quot;2.1 布局原理&quot;">​</a></h3><p>flex 是 flexible Box 的缩写，意为&quot;弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。</p><ul><li>当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</li><li>伸缩布局=弹性布局=伸缩盒布局=弹性盒布局=flex 布局</li></ul><p>采用 Flex 布局的元素，称为 Flex 容器( flex container )，简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项( flex item )，简称&quot;项目&quot;。</p><ul><li>体验中 div 就是 flex 父容器。</li><li>体验中 span 就是子容器 flex 项目</li><li>子容器可以横向排列也可以纵向排列</li></ul><p><strong>总结 flex 布局原理 ∶</strong> 就是通过给父盒子添加 flex 属性，来控制子盒子的位置和排列方式</p><h2 id="_3-flex-布局父项常见属性" tabindex="-1">3.flex 布局父项常见属性 <a class="header-anchor" href="#_3-flex-布局父项常见属性" aria-label="Permalink to &quot;3.flex 布局父项常见属性&quot;">​</a></h2><h3 id="_3-1-常见父项属性" tabindex="-1">3.1 常见父项属性 <a class="header-anchor" href="#_3-1-常见父项属性" aria-label="Permalink to &quot;3.1 常见父项属性&quot;">​</a></h3><p>以下由 6 个属性是对父元素设置的</p><ul><li>flex-direction :设置主轴的方向</li><li>justify-content :设置主轴上的子元素排列方式 flex-wrap∶ 设置子元素是否换行</li><li>align-content:设置侧轴上的子元素的排列方式(多行)</li><li>align-items :设置侧轴上的子元素排列方式(单行)</li><li>flex-flow :复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><h3 id="_3-2-flex-direction-设置主轴的方向-★" tabindex="-1">3.2 flex-direction 设置主轴的方向 ★ <a class="header-anchor" href="#_3-2-flex-direction-设置主轴的方向-★" aria-label="Permalink to &quot;3.2 flex-direction 设置主轴的方向 ★&quot;">​</a></h3><h4 id="_3-2-1-主轴与侧轴" tabindex="-1">3.2.1 主轴与侧轴 <a class="header-anchor" href="#_3-2-1-主轴与侧轴" aria-label="Permalink to &quot;3.2.1 主轴与侧轴&quot;">​</a></h4><p>在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ∶ 行和列、x 轴和 y 轴</p><ul><li>默认主轴方向就是 x 轴方向，水平向右</li><li>默认侧轴方向就是 y 轴方向，水平向下</li></ul><p>主轴，水平向右 -----------------------&gt; | | |侧轴，垂直向下</p><h4 id="_3-2-2-属性值" tabindex="-1">3.2.2 属性值 <a class="header-anchor" href="#_3-2-2-属性值" aria-label="Permalink to &quot;3.2.2 属性值&quot;">​</a></h4><p>flex-direction 属性决定主轴的方向(即项目的排列方向) 注意 ∶ 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</p><table tabindex="0"><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>row</td><td>默认值从左到右</td></tr><tr><td>row-reverse</td><td>从右到左</td></tr><tr><td>column</td><td>从上到下</td></tr><tr><td>column-reverse</td><td>从下到上</td></tr></tbody></table><h3 id="_3-3-justify-content-设置主轴上的子元素排列方式-★" tabindex="-1">3.3 justify-content 设置主轴上的子元素排列方式 ★ <a class="header-anchor" href="#_3-3-justify-content-设置主轴上的子元素排列方式-★" aria-label="Permalink to &quot;3.3 justify-content 设置主轴上的子元素排列方式 ★&quot;">​</a></h3><p>justify-content 属性定义了项目在主轴上的对齐方式 注意 ∶ 使用这个属性之前一定要确定好主轴是哪个</p><table tabindex="0"><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值从头部开始如果主轴是 x 轴，则从左到右</td></tr><tr><td>flex-end</td><td>从尾部开始排列</td></tr><tr><td>center</td><td>在主轴居中对齐（如果主轴是 x 轴则水平居中)</td></tr><tr><td>space-around</td><td>平分剩余空间</td></tr><tr><td>space-between</td><td>先两边贴边再平分剩余空间(重要)</td></tr></tbody></table><h3 id="_3-4-flex-wrap-设置子元素是否换行-★" tabindex="-1">3.4 flex-wrap 设置子元素是否换行 ★ <a class="header-anchor" href="#_3-4-flex-wrap-设置子元素是否换行-★" aria-label="Permalink to &quot;3.4 flex-wrap 设置子元素是否换行 ★&quot;">​</a></h3><p>默认情况下，项目都排在一条线(又称轴线”)上。flex-wrap 属性定义，flex 布局中默认是不换行的。</p><table tabindex="0"><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>nowrap</td><td>默认值，不换行</td></tr><tr><td>wrap</td><td>换行</td></tr></tbody></table><h3 id="_3-5-align-items-设置侧轴上的子元素排列方式-单行-★" tabindex="-1">3.5 align-items 设置侧轴上的子元素排列方式(单行)★ <a class="header-anchor" href="#_3-5-align-items-设置侧轴上的子元素排列方式-单行-★" aria-label="Permalink to &quot;3.5 align-items 设置侧轴上的子元素排列方式(单行)★&quot;">​</a></h3><p>该属性是控制子项在侧轴（默认是 y 轴）上的排列方式在子项为单项的时候使用</p><table tabindex="0"><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>从上到下</td></tr><tr><td>flex-end</td><td>从下到上</td></tr><tr><td>center</td><td>挤在一起居中（垂直居中)</td></tr><tr><td>stretch</td><td>拉伸（默认值)</td></tr></tbody></table><p>3.6 align-content 设置侧轴上的子元素的排列方式(多行) 设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况(多行），在单行下是没有效果的。</p><table tabindex="0"><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值在侧轴的头部开始排列</td></tr><tr><td>flex-end</td><td>在侧轴的尾部开始排列</td></tr><tr><td>center</td><td>在侧轴中间显示</td></tr><tr><td>space-around</td><td>子项在侧轴平分剩余空间</td></tr><tr><td>space-between</td><td>子项在侧轴先分布在两头，再平分剩余空间</td></tr><tr><td>stretch</td><td>设置子项元素高度平分父元素高度</td></tr></tbody></table><h3 id="_3-6-align-content-和-align-items-区别" tabindex="-1">3.6 align-content 和 align-items 区别 <a class="header-anchor" href="#_3-6-align-content-和-align-items-区别" aria-label="Permalink to &quot;3.6 align-content 和 align-items 区别&quot;">​</a></h3><ul><li>align-items 适用于单行情况下，只有上对齐、下对齐、居中和拉伸</li><li>align-content 适应于换行(多行)的情况下（单行情况下无效），可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</li><li>总结就是单行找 align-items 多行找 align-content</li></ul><h3 id="_3-7-flex-flow" tabindex="-1">3.7 flex-flow <a class="header-anchor" href="#_3-7-flex-flow" aria-label="Permalink to &quot;3.7 flex-flow&quot;">​</a></h3><p>flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>flex-flow : row wrap;</span></span></code></pre></div><ul><li>flex-direction :设置主轴的方向</li><li>justify-content:设置主轴上的子元素排列方式</li><li>flex-wrap∶ 设置子元素是否换行</li><li>align-content :设置侧轴上的子元素的排列方式(多行)</li><li>align-items:设置侧轴上的子元素排列方式(单行)</li><li>flex-flow :复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><h2 id="_4-flex-布局子项常见属性" tabindex="-1">4.flex 布局子项常见属性 <a class="header-anchor" href="#_4-flex-布局子项常见属性" aria-label="Permalink to &quot;4.flex 布局子项常见属性&quot;">​</a></h2><ul><li>flex 子项目占的份数</li><li>align-self 控制子项自己在侧轴的排列方媒</li><li>order 属性定义子项的排列顺序(前后顺序)</li></ul><h3 id="_4-1-flex-属性-★" tabindex="-1">4.1 flex 属性 ★ <a class="header-anchor" href="#_4-1-flex-属性-★" aria-label="Permalink to &quot;4.1 flex 属性 ★&quot;">​</a></h3><p>flex 属性定义子项目分配剩余空间，用 flex 来表示占多少份数。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: &lt;number&gt;; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* default o*/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_4-2-align-self-控制子项自己在侧轴上的排列方式" tabindex="-1">4.2 align-self 控制子项自己在侧轴上的排列方式 <a class="header-anchor" href="#_4-2-align-self-控制子项自己在侧轴上的排列方式" aria-label="Permalink to &quot;4.2 align-self 控制子项自己在侧轴上的排列方式&quot;">​</a></h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">nth-child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (2) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /*设置自己在侧轴上的排列方式*/</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  align-self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_4-3-order-属性定义项目的排列顺序" tabindex="-1">4.3 order 属性定义项目的排列顺序 <a class="header-anchor" href="#_4-3-order-属性定义项目的排列顺序" aria-label="Permalink to &quot;4.3 order 属性定义项目的排列顺序&quot;">​</a></h3><p>数值越小，排列越靠前，默认为 0。 注意:和 z-index 不一样。</p>`,54),n=[s];function r(d,h,o,p,f,c){return a(),e("div",null,n)}const b=t(i,[["render",r]]);export{u as __pageData,b as default};
