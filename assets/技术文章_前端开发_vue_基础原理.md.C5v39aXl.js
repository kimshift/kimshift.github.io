import{_ as e,q as a,p as t,aE as i}from"./chunks/framework.-H45_L2h.js";const v=JSON.parse('{"title":"vue基础原理","description":"","frontmatter":{"title":"vue基础原理","date":"2023-06-01T15:07:25.000Z","categories":["前端开发"],"tags":["vue"]},"headers":[],"relativePath":"技术文章/前端开发/vue/基础原理.md","filePath":"技术文章/前端开发/vue/基础原理.md","lastUpdated":1723096133000}'),l={name:"技术文章/前端开发/vue/基础原理.md"},o=i('<h1 id="vue-基础原理" tabindex="-1">vue 基础原理 <a class="header-anchor" href="#vue-基础原理" aria-label="Permalink to &quot;vue 基础原理&quot;">​</a></h1><h2 id="单页应用-spa" tabindex="-1">单页应用(SPA) <a class="header-anchor" href="#单页应用-spa" aria-label="Permalink to &quot;单页应用(SPA)&quot;">​</a></h2><p>可以构建 SPA 应用的,并且比较热门的框架有三个，React,Vue,Angular,当然他们也可以构建 MPA 应用</p><p>SPA 的核心概念包括两个方面:数据传递和页面切换,页面切换一般指的是路由，包括路由的配置,跳转和监听，数据传递又可以分为组件内传递【单向数据流,双向数据绑定），组件之间传递【组件属性,回调事件，全局状态)，以及页面之间传递（路由参数，公共缓存）</p><h2 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-label="Permalink to &quot;MVVM&quot;">​</a></h2><p>MVVM 的实现主要是三个核心点:</p><ul><li>响应式:vue 如何监听 data 的属性变化</li><li>模板解析:vue 的模板是如何被解析的</li><li>宣染:vue 模板是如何被渲染成 HTML 的</li></ul><h2 id="data-为什么是函数" tabindex="-1">data 为什么是函数 <a class="header-anchor" href="#data-为什么是函数" aria-label="Permalink to &quot;data 为什么是函数&quot;">​</a></h2><p>如果组件中的 data 不是一个函数,首先 vue 会报错,因为它内部规范组件中的 data 必须是一个函数。我们让 data 成为一个函数,且返回的是一个未定义对象,这样子就不会和上面返回是一个在全局作用域定义的对象,造成数据共享。因为此时我们每一次返回的对象的地址是不一样的,所以在组件对值进行修改的时候,会寻找对应组件的 data 返回对象的地址,这样子就能很好的控制组件数据独立了。</p><h2 id="v-model-的原理" tabindex="-1">v-model 的原理 <a class="header-anchor" href="#v-model-的原理" aria-label="Permalink to &quot;v-model 的原理&quot;">​</a></h2><p>v-model 是:value=&quot;msg&quot;@input=&quot;msg=$event.target.value&quot;的语法糖,其中:value=&quot;msg&quot;是绑定了数据,value就是inpuit输入框里的值;input=&quot;msg=$event.target.value&quot;就是监听 input 输入框里值的变化，然后改变值。一句话概括就是,<strong>绑定数据并且监听数据改变</strong>。</p><h2 id="vue-的响应式原理-双向数据绑定" tabindex="-1">Vue 的响应式原理(双向数据绑定) <a class="header-anchor" href="#vue-的响应式原理-双向数据绑定" aria-label="Permalink to &quot;Vue 的响应式原理(双向数据绑定)&quot;">​</a></h2><ol><li>实现一个监听器 Observer,用来劫持并监听所有属性,如果有变动的,就通知订阅者。</li><li>实现一个订词者 Watcher,可以收到属性的变 L 通知并执行相应的函数,从而更新视图。</li><li>实现一个解析器 Compile,可以扫描和解析每个节点的相关指令,并根据初始化模板数据以及初始化相应的订询器。</li></ol><h2 id="v-if-和-v-show-的区别" tabindex="-1">V-if 和 v-show 的区别 <a class="header-anchor" href="#v-if-和-v-show-的区别" aria-label="Permalink to &quot;V-if 和 v-show 的区别&quot;">​</a></h2><ol><li>实现本质方法区别 <ul><li>v-show 本质就是标签 display 设置为 none,控制隐藏</li><li>v-if 是动态的向 DOM 内添加或者删除 DOM 元素</li></ul></li><li>编译的区别 <ul><li>v-show 其实就是在控制 css</li><li>v-i 子切换有一个局部编译/卸载的过程,切换过程中合适地销毁和重建内部的事件监听和子组件</li></ul></li><li>编译的条件 <ul><li>v-show 都会编译,初始值为 false,只是游 display 设为 none,但它也编译了</li><li>v-if 初始值为 false,就不会编译了</li></ul></li><li>性能 v-show 只编译一次,后面其实就是控制 css,而 v-if 不停的销毁和创建,故 v-show 性能更好一点。</li></ol><h2 id="comeputed、watch-和-methods" tabindex="-1">comeputed、watch 和 methods <a class="header-anchor" href="#comeputed、watch-和-methods" aria-label="Permalink to &quot;comeputed、watch 和 methods&quot;">​</a></h2><h3 id="computed-与-methods-的区别" tabindex="-1">computed 与 methods 的区别 <a class="header-anchor" href="#computed-与-methods-的区别" aria-label="Permalink to &quot;computed 与 methods 的区别&quot;">​</a></h3><ul><li><p>computed 是响应式的,methods 并非响应式。</p></li><li><p>调用方式不一样,computed 定义的成员像属性一样访问，methods 定义的成员必须以函数形式调用。</p></li><li><p>computed 是带缓存的,只有其引用的响应式属性发生改变时中会重新计算,而 methods 里的函数在每次调用时都要执行。</p></li><li><p>computed 中的成员可以只定义一个函数作为只读属性,也可以定义 get/set 变成可读写属性,这点是 methods 中的成员做不到的</p></li></ul><h3 id="computed-属性和-watch-区别" tabindex="-1">computed 属性和 watch 区别 <a class="header-anchor" href="#computed-属性和-watch-区别" aria-label="Permalink to &quot;computed 属性和 watch 区别&quot;">​</a></h3><ul><li>computed 里属性名是自定义的,它可以监听一个或多个它所依赖的数据项;而 watch 一次只能监听一个属性,这个属性函数接收两个参数,一个是新值一个是旧值。</li><li>computed 里自定义的属性<strong>不能与 data 里的属性重复</strong>,否则会报错;而 watch 里监听的属性必须是已存在的,其要么是 data 里的属性,要么是 computed 里计算出来的属性。</li><li>watch 是允许异步操作的(访问一个 API),并在我们得到最络结果前,设置中间状态。这些都是计算属性无法做到的。</li></ul><h2 id="vue-的生金周期" tabindex="-1">Vue 的生金周期 <a class="header-anchor" href="#vue-的生金周期" aria-label="Permalink to &quot;Vue 的生金周期&quot;">​</a></h2><p>在 new Vue()的对象过程当中,首先执行了 init ( init 是 vue 组件里面默认去执行的）,在 init 的过程当中首先调用了 beforeCreate,然后在 injections(注射）和 reactivity(反应性）的时候,它 会再去调用 created。</p><p>所以在 init 的时候,事件已经调用了,我们在 beforeCreate 的时候千万不要去修改 data 里面赋值的数据,最早也要放在 created 里面去做(添加一些行为)。</p><p>当 created 完成之后,它会去判断 instance(实例)里面是否含有“el&quot; option(选项）,如果没有的话,它会调用 vm.Smount(el)这个方法,然后执行下一步;如果有的话，直接执行下一步。</p><p>紧接着会判断是否含有“template”这个选项,如果有的话,它会把 template 解析成一个 render function,这是一个 template 编译的过程,结果是解析新成了 render 函数。</p><h2 id="vue-组件间通信的访式" tabindex="-1">Vue 组件间通信的访式 <a class="header-anchor" href="#vue-组件间通信的访式" aria-label="Permalink to &quot;Vue 组件间通信的访式&quot;">​</a></h2><ol><li>props/$emit 方法</li><li>$emit/$on</li><li>vuex</li><li>$attrs/$listeners</li><li>provide/inject</li></ol><h2 id="父子组件生命周期顺序" tabindex="-1">父子组件生命周期顺序 <a class="header-anchor" href="#父子组件生命周期顺序" aria-label="Permalink to &quot;父子组件生命周期顺序&quot;">​</a></h2><p>父组件 beforeCreate(创建前)-&gt;父组件 created(创建后)-&gt;父组件 beforeMount(挂载前)-&gt;子组件 beforeCreate-&gt;千组件 created-&gt;子组件 beforeMount-&gt;子组件 mounted(挂载后)-&gt;父组件 mounted</p>',29),r=[o];function u(d,h,s,n,c,m){return t(),a("div",null,r)}const f=e(l,[["render",u]]);export{v as __pageData,f as default};
