import{_ as s,q as i,p as a,aE as t}from"./chunks/framework.-H45_L2h.js";const n="/assets/image-20210218010732328.DI3ND8Ac.png",l="/assets/image-20210218165354752.Dk84IigM.png",u=JSON.parse('{"title":"3.BOM浏览器对象模型","description":"","frontmatter":{"title":"3.BOM浏览器对象模型","date":"2023-06-02T10:53:38.000Z","categories":["前端开发"],"tags":["javascript","js基础"],"prev":"2.Web APl简介","next":"4.PC端网页特效"},"headers":[],"relativePath":"技术文章/前端开发/javascript/js基础/3.BOM浏览器对象模型.md","filePath":"技术文章/前端开发/javascript/js基础/3.BOM浏览器对象模型.md","lastUpdated":1723096133000}'),e={name:"技术文章/前端开发/javascript/js基础/3.BOM浏览器对象模型.md"},h=t('<h1 id="_3-bom-浏览器对象模型" tabindex="-1">3.BOM 浏览器对象模型 <a class="header-anchor" href="#_3-bom-浏览器对象模型" aria-label="Permalink to &quot;3.BOM 浏览器对象模型&quot;">​</a></h1><h2 id="_1-bom-概述" tabindex="-1">1. BOM 概述 <a class="header-anchor" href="#_1-bom-概述" aria-label="Permalink to &quot;1. BOM 概述&quot;">​</a></h2><h3 id="_1-1-什么是-bom" tabindex="-1">1.1 什么是 BOM <a class="header-anchor" href="#_1-1-什么是-bom" aria-label="Permalink to &quot;1.1 什么是 BOM&quot;">​</a></h3><p>BOM（Browser Object Model）即<strong>浏览器对象模型</strong>，它提供了独立于内容而与<strong>浏览器窗口进行交互的对象</strong>，其核心 对象是 window。</p><p>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</p><p>BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是 Netscape 浏 览器标准的一部分。</p><p><strong>DOM</strong></p><ul><li>文档对象模型</li><li>DOM 就是把「文档」当做一个「对象」来看待</li><li>DOM 的顶级对象是<strong>document</strong></li><li>DOM 主要学习的是操作页面元素</li><li>DOM 是 W3C 标准规范</li></ul><p><strong>BOM</strong></p><ul><li><p>浏览器对象模型</p></li><li><p>把「浏览器」当做一个「对象」来看待</p></li><li><p>BOM 的顶级对象是 window</p></li><li><p>BOM 学习的是浏览器窗口交互的一些对象</p></li><li><p>BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差</p></li></ul><h4 id="_1-2-bom-的构成" tabindex="-1">1.2 BOM 的构成 <a class="header-anchor" href="#_1-2-bom-的构成" aria-label="Permalink to &quot;1.2 BOM 的构成&quot;">​</a></h4><p>BOM 比 DOM 更大，它包含 DOM。</p><p><img src="'+n+`" alt="image-20210218010732328" loading="lazy"></p><p>window 对象是浏览器的顶级对象，它具有双重角色。</p><ol><li>它是 JS 访问浏览器窗口的一个接口。</li><li>它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。</li></ol><p>在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt() 等。</p><p><strong>注意</strong>：window 下的一个特殊属性 window.name</p><h2 id="_2-window-对象的常见事件" tabindex="-1">2. window 对象的常见事件 <a class="header-anchor" href="#_2-window-对象的常见事件" aria-label="Permalink to &quot;2. window 对象的常见事件&quot;">​</a></h2><h3 id="_2-1-窗口加载事件" tabindex="-1">2.1 窗口加载事件 <a class="header-anchor" href="#_2-1-窗口加载事件" aria-label="Permalink to &quot;2.1 窗口加载事件&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>window.onload = function(){}</span></span>
<span class="line"><span>或者</span></span>
<span class="line"><span>window.addEventListener(&quot;load&quot;,function(){});</span></span></code></pre></div><p>window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</p><p><strong>注意</strong>：</p><ol><li>有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， 再去执行处理函数。</li><li>window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个 window.onload 为准。</li><li>如果使用 addEventListener 则没有限制</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>document.addEventListener(&#39;DOMContentLoaded&#39;,function(){})</span></span></code></pre></div><p>DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash 等等。</p><p>Ie9 以上才支持</p><p>如果页面的图片很多的话, 从用户访问到 onload 触发可能需要较长的时间, 交互效果就不能实现，必然影响用 户的体验，此时用 DOMContentLoaded 事件比较合适。</p><h3 id="_2-2-调整窗口大小事件" tabindex="-1">2.2 调整窗口大小事件 <a class="header-anchor" href="#_2-2-调整窗口大小事件" aria-label="Permalink to &quot;2.2 调整窗口大小事件&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>window.onresize = function(){}</span></span>
<span class="line"><span>window.addEventListener(&quot;resize&quot;,function(){});</span></span></code></pre></div><p>window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。</p><p><strong>注意：</strong></p><ol><li>只要窗口大小发生像素变化，就会触发这个事件。</li><li>我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度</li></ol><h2 id="_3-定时器" tabindex="-1">3. 定时器 <a class="header-anchor" href="#_3-定时器" aria-label="Permalink to &quot;3. 定时器&quot;">​</a></h2><h3 id="_3-1-两种定时器" tabindex="-1">3.1 两种定时器 <a class="header-anchor" href="#_3-1-两种定时器" aria-label="Permalink to &quot;3.1 两种定时器&quot;">​</a></h3><p>window 对象给我们提供了 2 个非常好用的方法-定时器。</p><ul><li>setTimeout()</li><li>setInterval()</li></ul><h3 id="_3-2-settimeout-定时器" tabindex="-1">3.2 setTimeout() 定时器 <a class="header-anchor" href="#_3-2-settimeout-定时器" aria-label="Permalink to &quot;3.2 setTimeout() 定时器&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>window.setTimeout(调用函数, [延迟的毫秒数]);</span></span></code></pre></div><p>setTimeout() 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。</p><p>注意：</p><ol><li>window 可以省略。</li><li>这个调用函数可以<strong>直接写函数，或者写函数名</strong>或者采取字符串**‘函数名()&#39;**三种形式。第三种不推荐</li><li>延迟的毫秒数省略默认是 0，如果写，必须是毫秒。</li><li>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</li></ol><p>setTimeout() 这个调用函数我们也称为<strong>回调函数 callback</strong></p><p>普通函数是按照代码顺序直接调用。</p><p>而这个函数，<strong>需要等待</strong>时间，时间到了才去调用这个函数，因此称为回调函数。</p><p>简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。</p><p>以前我们讲的 element.onclick = function(){} 或者 element.addEventListener(“click”, fn); 里面的 函数也是回调 函数。</p><h3 id="_3-3-停止-settimeout-定时器" tabindex="-1">3.3 停止 setTimeout() 定时器 <a class="header-anchor" href="#_3-3-停止-settimeout-定时器" aria-label="Permalink to &quot;3.3 停止 setTimeout() 定时器&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> window.clearTimeout(timeoutID)</span></span></code></pre></div><p>clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。</p><p><strong>注意</strong>：</p><ol><li>window 可以省略。</li><li>里面的参数就是定时器的标识符 。</li></ol><h3 id="_3-4-setinterval-定时器" tabindex="-1">3.4 setInterval() 定时器 <a class="header-anchor" href="#_3-4-setinterval-定时器" aria-label="Permalink to &quot;3.4 setInterval() 定时器&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> window.setInterval(回调函数, [间隔的毫秒数]);</span></span></code></pre></div><p>setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。</p><p>注意：</p><ol><li>window 可以省略。</li><li>这个调用函数可以<strong>直接写函数，或者写函数名</strong>或者采取字符串 <strong>&#39;函数名()&#39;</strong> 三种形式。</li><li>间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。</li><li>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</li><li>第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。</li></ol><h3 id="_3-5-停止-setinterval-定时器" tabindex="-1">3.5 停止 setInterval() 定时器 <a class="header-anchor" href="#_3-5-停止-setinterval-定时器" aria-label="Permalink to &quot;3.5 停止 setInterval() 定时器&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>window.clearInterval(intervalID);</span></span></code></pre></div><p>clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。</p><p><strong>注意</strong>：</p><ol><li>window 可以省略。</li><li>里面的参数就是定时器的标识符 。</li></ol><h3 id="_3-6-this" tabindex="-1">3.6 this <a class="header-anchor" href="#_3-6-this" aria-label="Permalink to &quot;3.6 this&quot;">​</a></h3><p>this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，一般情况下 this 的最终指向的是那个调用它的对象</p><p>现阶段，我们先了解一下几个 this 指向</p><ol><li>全局作用域或者普通函数中 this 指向全局对象 window（注意定时器里面的 this 指向 window）</li><li>方法调用中谁调用 this 指向谁</li><li>构造函数中 this 指向构造函数的实例</li></ol><h2 id="_4-js-执行机制" tabindex="-1">4. JS 执行机制 <a class="header-anchor" href="#_4-js-执行机制" aria-label="Permalink to &quot;4. JS 执行机制&quot;">​</a></h2><h3 id="_4-1-js-是单线程" tabindex="-1">4.1 JS 是单线程 <a class="header-anchor" href="#_4-1-js-是单线程" aria-label="Permalink to &quot;4.1 JS 是单线程&quot;">​</a></h3><p>JavaScript 语言的一大特点就是<strong>单线程</strong>，也就是说，<strong>同一个时间只能做一件事</strong>。这是因为 Javascript 这门脚 本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对 某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。</p><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><p>PS1:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//1 2 3</span></span></code></pre></div><p>PS2:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//1 2 3</span></span></code></pre></div><h3 id="_4-2-同步和异步" tabindex="-1">4.2 同步和异步 <a class="header-anchor" href="#_4-2-同步和异步" aria-label="Permalink to &quot;4.2 同步和异步&quot;">​</a></h3><p>为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创 建多个线程。于是，JS 中出现了<strong>同步</strong>和<strong>异步</strong>。</p><p><strong>同步</strong></p><p>前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做 法：我们要烧水煮饭，等水开了（10 分钟之后），再去切菜，炒菜。</p><p><strong>异步</strong></p><p>你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做 饭的异步做法，我们在烧水的同时，利用这 10 分钟，去切菜，炒菜。</p><p><strong>本质区别</strong>： 这条流水线上各个流程的执行顺序不同。</p><h3 id="_4-3-同步任务和异步任务" tabindex="-1">4.3 同步任务和异步任务 <a class="header-anchor" href="#_4-3-同步任务和异步任务" aria-label="Permalink to &quot;4.3 同步任务和异步任务&quot;">​</a></h3><p><strong>同步任务</strong></p><p>同步任务都在主线程上执行，形成一个<strong>执行栈</strong>。</p><p><strong>异步任务</strong></p><p>JS 的异步是通过回调函数实现的。</p><p>一般而言，异步任务有以下三种类型:</p><ol><li><p>普通事件，如 click、resize 等</p></li><li><p>资源加载，如 load、error 等</p></li><li><p>定时器，包括 setInterval、setTimeout 等 异步任务相关<strong>回调函数</strong>添加到<strong>任务队列</strong>中（任务队列也称为消息队列）。</p></li></ol><h3 id="_4-4-js-执行机制" tabindex="-1">4.4 JS 执行机制 <a class="header-anchor" href="#_4-4-js-执行机制" aria-label="Permalink to &quot;4.4 JS 执行机制&quot;">​</a></h3><ol><li>先执行<strong>执行栈中的同步任务</strong>。</li><li>异步任务（回调函数）放入任务队列中。</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取<strong>任务队列</strong>中的异步任务，于是被读取的异步任 务结束等待状态，进入执行栈，开始执行。 <img src="`+l+`" alt="image-20210218165354752" loading="lazy"></li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。</p><h2 id="_5-location-对象" tabindex="-1">5. location 对象 <a class="header-anchor" href="#_5-location-对象" aria-label="Permalink to &quot;5. location 对象&quot;">​</a></h2><h3 id="_5-1-什么是-location-对象" tabindex="-1">5.1 什么是 location 对象 <a class="header-anchor" href="#_5-1-什么是-location-对象" aria-label="Permalink to &quot;5.1 什么是 location 对象&quot;">​</a></h3><p>window 对象给我们提供了一个 <strong>location 属性</strong>用于<strong>获取或设置窗体的 URL</strong>，并且可以用于解析 URL 。 因为 这个属性返回的是一个对象，所以我们将这个属性也称为 <strong>location 对象</strong>。</p><h3 id="_5-2-url" tabindex="-1">5.2 URL <a class="header-anchor" href="#_5-2-url" aria-label="Permalink to &quot;5.2 URL&quot;">​</a></h3><p><strong>统一资源定位符 (Uniform Resource Locator, URL)</strong> 是互联网上标准资源的地址。互联网上的每个文件都有 一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 URL 的一般语法格式为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>protocol://host[:port]/path/[?query]#fragment</span></span>
<span class="line"><span>http://www.itcast.cn/index.html?name=andy&amp;age=18#link</span></span></code></pre></div><table tabindex="0"><thead><tr><th>组成</th><th>说明</th></tr></thead><tbody><tr><td>protocol</td><td>通信协议常用的 http,ftp,maito 等</td></tr><tr><td>host</td><td>主机(域名)</td></tr><tr><td>port</td><td>端口号可选，省略时使用方案的默认端口如 http 的默认端口为 80</td></tr><tr><td>path</td><td>路径由零或多个/符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</td></tr><tr><td>query</td><td>参数以键值对的形式,通过&amp;符号分隔开来</td></tr><tr><td>fragment</td><td>片段#后面内容常见于链接锚点</td></tr></tbody></table><h3 id="_5-3-location-对象的属性" tabindex="-1">5.3 location 对象的属性 <a class="header-anchor" href="#_5-3-location-对象的属性" aria-label="Permalink to &quot;5.3 location 对象的属性&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">location.hash</td><td style="text-align:left;">返回一个 URL 的锚部分</td></tr><tr><td style="text-align:left;">location.host</td><td style="text-align:left;">返回一个 URL 的主机名和端口</td></tr><tr><td style="text-align:left;">location.hostname</td><td style="text-align:left;">返回 URL 的主机名</td></tr><tr><td style="text-align:left;">location.href</td><td style="text-align:left;">返回完整的 URL</td></tr><tr><td style="text-align:left;">location.pathname</td><td style="text-align:left;">返回的 URL 路径名。</td></tr><tr><td style="text-align:left;">location.port</td><td style="text-align:left;">返回一个 URL 服务器使用的端口号</td></tr><tr><td style="text-align:left;">location.protocol</td><td style="text-align:left;">返回一个 URL 协议</td></tr><tr><td style="text-align:left;">location.search</td><td style="text-align:left;">返回一个 URL 的查询部分</td></tr></tbody></table><p>重点记住： href 和 search</p><h3 id="_5-4-location-对象的方法" tabindex="-1">5.4 location 对象的方法 <a class="header-anchor" href="#_5-4-location-对象的方法" aria-label="Permalink to &quot;5.4 location 对象的方法&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">assign()</td><td style="text-align:left;">跟 href—样，可以跳转页面(也称为重定向页面)</td></tr><tr><td style="text-align:left;">reload()</td><td style="text-align:left;">替换当前页面，因为不记录历史，所以不能后退页面</td></tr><tr><td style="text-align:left;">replace()</td><td style="text-align:left;">重新加载页面，相当于刷新按钮或者 f5 如果参数为 true 强制刷新 ctrl+f5</td></tr></tbody></table><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.location.href </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //界面跳转</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.location.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//界面重载</span></span></code></pre></div><h2 id="_6-navigator-对象" tabindex="-1">6. navigator 对象 <a class="header-anchor" href="#_6-navigator-对象" aria-label="Permalink to &quot;6. navigator 对象&quot;">​</a></h2><p>navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客 户机发送服务器的 user-agent 头部的值。</p><p>下面前端代码可以判断用户那个终端打开页面，实现跳转</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  navigator.userAgent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    /</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">(phone</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">pad</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">pod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">iPhone</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">iPod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">ios</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">iPad</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">Android</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> Mobile </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> BlackBerry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> IEMobile </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> MQQBrowser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> JUC </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> Fennec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> wOSBrowser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> BrowserNG </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> WebOS </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> Symbian </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> Windows Phone) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">i</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  window.location.href </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //手机</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  window.location.href </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //电脑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_7-history-对象" tabindex="-1">7. history 对象 <a class="header-anchor" href="#_7-history-对象" aria-label="Permalink to &quot;7. history 对象&quot;">​</a></h2><p>window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中） 访问过的 URL。</p><table tabindex="0"><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">back()</td><td style="text-align:left;">加载 history 列表中的前一个 URL（后退）</td></tr><tr><td style="text-align:left;">forward()</td><td style="text-align:left;">加载 history 列表中的下一个 URL（前进）</td></tr><tr><td style="text-align:left;">go()</td><td style="text-align:left;">加载 history 列表中的某个具体页面</td></tr></tbody></table><p>history 对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。</p>`,112),p=[h];function o(r,d,k,g,c,E){return a(),i("div",null,p)}const F=s(e,[["render",o]]);export{u as __pageData,F as default};
