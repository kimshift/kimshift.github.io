import{_ as t,q as a,p as i,aE as s}from"./chunks/framework.-H45_L2h.js";const u=JSON.parse('{"title":"7.响应式布局","description":"","frontmatter":{"title":"7.响应式布局","date":"2023-06-02T10:00:03.000Z","categories":["前端开发"],"tags":["html"],"prev":"6.rem适配布局","next":false},"headers":[],"relativePath":"技术文章/前端开发/html/7.响应式布局.md","filePath":"技术文章/前端开发/html/7.响应式布局.md","lastUpdated":1723096133000}'),l={name:"技术文章/前端开发/html/7.响应式布局.md"},d=s(`<h1 id="_7-响应式布局" tabindex="-1">7.响应式布局 <a class="header-anchor" href="#_7-响应式布局" aria-label="Permalink to &quot;7.响应式布局&quot;">​</a></h1><h2 id="_1-响应式开发" tabindex="-1">1.响应式开发 <a class="header-anchor" href="#_1-响应式开发" aria-label="Permalink to &quot;1.响应式开发&quot;">​</a></h2><h3 id="_1-1-响应式开发原理" tabindex="-1">1.1 响应式开发原理 <a class="header-anchor" href="#_1-1-响应式开发原理" aria-label="Permalink to &quot;1.1 响应式开发原理&quot;">​</a></h3><p>就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。</p><table tabindex="0"><thead><tr><th>设备划分</th><th>尺寸区间</th></tr></thead><tbody><tr><td>超小屏幕（手机)</td><td>&lt; 768px</td></tr><tr><td>小屏设备（ 平板)</td><td>768px ~ 992px</td></tr><tr><td>中等屏幕（桌面显示器）</td><td>992px ~ 1200px</td></tr><tr><td>宽屏设备(大桌面显示器)</td><td>&gt;= 1200px</td></tr></tbody></table><h3 id="_1-2-响应式布局容器" tabindex="-1">1.2 响应式布局容器 <a class="header-anchor" href="#_1-2-响应式布局容器" aria-label="Permalink to &quot;1.2 响应式布局容器&quot;">​</a></h3><p>响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。 原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。 <strong>平时我们的响应式尺寸划分</strong></p><ul><li>超小屏幕（手机，小于 768px )︰设置宽度为 100%</li><li>小屏幕（平板，大于等于 768px)︰设置宽度为 750px</li><li>中等屏幕（桌面显示器，大于等于 992px ):宽度设置为 970px</li><li>大屏幕(大桌面显示器，大于等于 1200px ) :宽度设置为 1170px</li></ul><h2 id="_2-bootstrap-前端开发框架" tabindex="-1">2.Bootstrap 前端开发框架 <a class="header-anchor" href="#_2-bootstrap-前端开发框架" aria-label="Permalink to &quot;2.Bootstrap 前端开发框架&quot;">​</a></h2><h3 id="_2-1-bootstrap-简介" tabindex="-1">2.1 Bootstrap 简介 <a class="header-anchor" href="#_2-1-bootstrap-简介" aria-label="Permalink to &quot;2.1 Bootstrap 简介&quot;">​</a></h3><p>Bootstrap 来自 Twitter(推特），是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS 和 JAVASCRIPT 的，它简洁灵活，<strong>使得 Web 开发更加快捷。</strong></p><ul><li>中文官网: <a href="http://www.bootcss.com/" target="_blank" rel="noreferrer">http://www.bootcss.com/</a></li><li>官网: <a href="http://getbootstrap.com/" target="_blank" rel="noreferrer">http://getbootstrap.com/</a></li><li>推荐使用: <a href="http://bootstrap.css88.com/" target="_blank" rel="noreferrer">http://bootstrap.css88.com/</a></li></ul><p><strong>框架</strong>∶ 顾名思义就是一套架构，它有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发。</p><p><strong>1.优点</strong></p><ul><li>标准化的 html+css 编码规范</li><li>提供了一套简洁、直观、强悍的组件</li><li>有自己的生态圈，不断的更新迭代</li><li>让开发更简单，提高了开发的效率</li></ul><h3 id="_2-2-bootstrap-使用" tabindex="-1">2.2 Bootstrap 使用 <a class="header-anchor" href="#_2-2-bootstrap-使用" aria-label="Permalink to &quot;2.2 Bootstrap 使用&quot;">​</a></h3><p>Bootstrap 使用四步曲 ∶1.创建文件夹结构 2.创建 html 骨架结构 3.引入相关样式文件 4.书写内容</p><h3 id="_2-3-布局容器" tabindex="-1">2.3 布局容器 <a class="header-anchor" href="#_2-3-布局容器" aria-label="Permalink to &quot;2.3 布局容器&quot;">​</a></h3><p>Bootstrap 需要为页面内容和栅格系统包裹一个.container 容器，Bootstarp 预先定义好了这个类，叫.container 它提供了两个作此用处的类。</p><ol><li>container 类</li></ol><ul><li>响应式布局的容器固定宽度</li><li>大屏( &gt;=1200px)宽度定为 1170px</li><li>中屏( &gt;=992px)宽度定为 970px</li><li>小屏(&gt;=768px)宽度定为 750px</li><li>超小屏(100%)</li></ul><ol start="2"><li>container-fluid 类 <ul><li>流式布局容器百分百宽度</li><li>占据全部视口( viewport )的容器。</li><li>适合于单独做移动端开发</li></ul></li></ol><h3 id="_2-4-栅格系统简介" tabindex="-1">2.4 栅格系统简介 <a class="header-anchor" href="#_2-4-栅格系统简介" aria-label="Permalink to &quot;2.4 栅格系统简介&quot;">​</a></h3><ul><li><strong>栅格系统</strong>英文为“gridsystems”,也有人翻译为“网格系统”，它是指将页面布局划分为等宽的列，然后通过列数的定义来模块化页面布局。</li><li>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口( viewport )尺寸的增加，系统会自动分为最多<strong>12</strong>列。</li><li>Bootstrap 里面 container 宽度是固定的，但是不同屏幕下，container 的宽度不同，我们再把 container 划分为 12 等份</li></ul><h3 id="_2-5-栅格选项参数" tabindex="-1">2.5 栅格选项参数 <a class="header-anchor" href="#_2-5-栅格选项参数" aria-label="Permalink to &quot;2.5 栅格选项参数&quot;">​</a></h3><p>栅格系统用于通过一系列的行( row )与列( column )的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。</p><table tabindex="0"><thead><tr><th></th><th>特小 &lt;576px</th><th>Small ≥576px</th><th>Medium ≥768px</th><th>Large ≥992px</th><th>特大 ≥1200px</th></tr></thead><tbody><tr><td>最大容器宽度</td><td>无（自动）</td><td>540 像素</td><td>720px</td><td>960px</td><td>1140px</td></tr><tr><td>类前缀</td><td><code>.col-</code></td><td><code>.col-sm-</code></td><td><code>.col-md-</code></td><td><code>.col-lg-</code></td><td><code>.col-xl-</code></td></tr><tr><td>列数</td><td>12</td><td></td><td></td><td></td><td></td></tr><tr><td>天沟宽度</td><td>30 像素（每列 15 像素）</td><td></td><td></td><td></td><td></td></tr><tr><td>可嵌套</td><td>是</td><td></td><td></td><td></td><td></td></tr><tr><td>列顺序</td><td>是</td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>行( row)必须放到 container 布局容器里面</li><li>我们实现列的平均划分需要给列添加类前缀</li><li>xs-extra small :超小 ; sm-small :小 ; md-medium :中等;lg-large :大;</li><li>列( column )大于 12，多余的“列 ( column )”所在的元素将被作为一个整体另起一行排列</li><li>每一列默认有左右 15 像素的 padding</li><li>可以同时为一列指定多个设备的类名，以便划分不同份数例如 class=&quot;col-md-4 col-sm-6&quot;</li></ul><h3 id="_2-6-列偏移" tabindex="-1">2.6 列偏移 <a class="header-anchor" href="#_2-6-列偏移" aria-label="Permalink to &quot;2.6 列偏移&quot;">​</a></h3><p>使用.col-md-offset-<em>类可以将列向右侧偏移。这些类实际是通过使用</em>选择器为当前元素增加了左侧的边距( margin ) 。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!--列偏移--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;row&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;col-lg-4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;1&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;col-lg-4 col-lg-offset-4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="_2-7-列排序" tabindex="-1">2.7 列排序 <a class="header-anchor" href="#_2-7-列排序" aria-label="Permalink to &quot;2.7 列排序&quot;">​</a></h3><p>通过使用.col-md-push-和.col-md-pull-类就可以很容易的改变列( column )的顺序。</p><h3 id="_2-8-响应式工具" tabindex="-1">2.8 响应式工具 <a class="header-anchor" href="#_2-8-响应式工具" aria-label="Permalink to &quot;2.8 响应式工具&quot;">​</a></h3><p>为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。</p><table tabindex="0"><thead><tr><th>类名</th><th>超小屏</th><th>小屏</th><th>中屏</th><th>大屏</th></tr></thead><tbody><tr><td>.hidden-xs</td><td>隐藏</td><td>可见</td><td>可见</td><td>可见</td></tr><tr><td>.hidden-sm</td><td>可见</td><td>隐藏</td><td>可见</td><td>可见</td></tr><tr><td>.hidden-md</td><td>可见</td><td>可见</td><td>隐藏</td><td>可见</td></tr><tr><td>.hidden-lg</td><td>可见</td><td>可见</td><td>可见</td><td>隐藏</td></tr></tbody></table><p>与之相反的，是 visible-xs visible-sm visible-md visible-lg 是显示某个页面内容</p>`,37),e=[d];function r(o,h,n,p,c,k){return i(),a("div",null,e)}const b=t(l,[["render",r]]);export{u as __pageData,b as default};
