import{_ as t,q as e,p as a,aE as l}from"./chunks/framework.-H45_L2h.js";const i="/assets/y5I9zUCTPqr2DAN.CMRVqMy_.png",u=JSON.parse('{"title":"4.PC端网页特效","description":"","frontmatter":{"title":"4.PC端网页特效","date":"2023-06-02T10:54:38.000Z","categories":["前端开发"],"tags":["javascript","js基础"],"prev":"3.BOM浏览器对象模型","next":"5.移动端特效"},"headers":[],"relativePath":"技术文章/前端开发/javascript/js基础/4.PC端网页特效.md","filePath":"技术文章/前端开发/javascript/js基础/4.PC端网页特效.md","lastUpdated":1723096133000}'),s={name:"技术文章/前端开发/javascript/js基础/4.PC端网页特效.md"},r=l(`<h1 id="_4-pc-端网页特效" tabindex="-1">4.PC 端网页特效 <a class="header-anchor" href="#_4-pc-端网页特效" aria-label="Permalink to &quot;4.PC 端网页特效&quot;">​</a></h1><h2 id="_1-元素偏移量-offset-系列" tabindex="-1">1. 元素偏移量 offset 系列 <a class="header-anchor" href="#_1-元素偏移量-offset-系列" aria-label="Permalink to &quot;1. 元素偏移量 offset 系列&quot;">​</a></h2><h3 id="_1-1-offset-概述" tabindex="-1">1.1 offset 概述 <a class="header-anchor" href="#_1-1-offset-概述" aria-label="Permalink to &quot;1.1 offset 概述&quot;">​</a></h3><p>offset 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p><ul><li>获得元素距离带有定位父元素的位置</li><li>获得元素自身的大小（宽度高度）</li><li>注意： 返回的数值都不带单位 1.1 offset 概述</li></ul><p>offset 系列常用属性：</p><table tabindex="0"><thead><tr><th>offset 系列属性</th><th>作用</th></tr></thead><tbody><tr><td>element.offsetParent</td><td>返回作为该元素带有定位的父级元素如果父级都没有定位则返回 body</td></tr><tr><td>element.offsetTop</td><td>返回元素相对带有定位父元素上方的偏移</td></tr><tr><td>element.offsetLeft</td><td>返回元,素相对带有定位父元,素左边框的偏移</td></tr><tr><td>element.offsetWidth</td><td>返回自身包括 padding、边框、内容区的宽度，返回数值不带单位</td></tr><tr><td>element.offsetHeight</td><td>返回自身包括 padding、边框、内容区的高度，返回数值不带单位</td></tr></tbody></table><h3 id="_1-2-offset-与-style-区别" tabindex="-1">1.2 offset 与 style 区别 <a class="header-anchor" href="#_1-2-offset-与-style-区别" aria-label="Permalink to &quot;1.2 offset 与 style 区别&quot;">​</a></h3><p><strong>offset</strong></p><ul><li>offset 可以得到任意样式表中的样式值</li><li>offset 系列获得的数值是没有单位的</li><li>offsetWidth 包含 padding+border+width</li><li>offsetWidth 等属性是只读属性，只能获取不能赋值</li><li><strong>所以，我们想要获取元素大小位置，用 offset 更合适</strong></li></ul><p><strong>style</strong></p><ul><li>style 只能得到行内样式表中的样式值</li><li>style.width 获得的是带有单位的字符串</li><li>style.width 获得不包含 padding 和 border 的值</li><li>style.width 是可读写属性，可以获取也可以赋值</li><li><strong>所以，我们想要给元素更改值，则需要用 style 改变</strong></li></ul><h2 id="_2-元素可视区-client-系列" tabindex="-1">2. 元素可视区 client 系列 <a class="header-anchor" href="#_2-元素可视区-client-系列" aria-label="Permalink to &quot;2. 元素可视区 client 系列&quot;">​</a></h2><p><strong>client</strong> 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列 的相关属性可以动态的得到该元素的边框大小、元素大小等。</p><table tabindex="0"><thead><tr><th>client 系列属性</th><th>作用</th></tr></thead><tbody><tr><td>element.clientTop</td><td>返回元素上边框的大小</td></tr><tr><td>element.clientLeft</td><td>返回元素左边框的大小</td></tr><tr><td>element.clientWidth</td><td>返回自身包括 padding、内容区的宽度，不含边框，返回数值不带单位</td></tr><tr><td>element.clientHeight</td><td>返回自身包括 padding、内容区的高度，不含边框，返回数值不带单位</td></tr></tbody></table><h2 id="_3-元素滚动-scroll-系列" tabindex="-1">3. 元素滚动 scroll 系列 <a class="header-anchor" href="#_3-元素滚动-scroll-系列" aria-label="Permalink to &quot;3. 元素滚动 scroll 系列&quot;">​</a></h2><h3 id="_3-1-元素-scroll-系列属性" tabindex="-1">3.1 元素 scroll 系列属性 <a class="header-anchor" href="#_3-1-元素-scroll-系列属性" aria-label="Permalink to &quot;3.1 元素 scroll 系列属性&quot;">​</a></h3><p><strong>scroll</strong> 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p><table tabindex="0"><thead><tr><th>scroll 系列属性</th><th>作用</th></tr></thead><tbody><tr><td>element.scrollTop</td><td>返回被卷去的上侧距离，返回数值不带单位</td></tr><tr><td>element.scrollLeft</td><td>返回被卷去的左侧距离，返回数值不带单位</td></tr><tr><td>element.scrollWidth</td><td>返回自身实际的宽度，不含边框，返回数值不带单位</td></tr><tr><td>element.scrollHeight</td><td>返回自身实际的高度，不含边框，返回数值不带单位</td></tr></tbody></table><h3 id="_3-2-页面被卷去的头部" tabindex="-1">3.2 页面被卷去的头部 <a class="header-anchor" href="#_3-2-页面被卷去的头部" aria-label="Permalink to &quot;3.2 页面被卷去的头部&quot;">​</a></h3><p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏 掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll 事件。</p><h3 id="_3-3-页面被卷去的头部兼容性解决方案" tabindex="-1">3.3 页面被卷去的头部兼容性解决方案 <a class="header-anchor" href="#_3-3-页面被卷去的头部兼容性解决方案" aria-label="Permalink to &quot;3.3 页面被卷去的头部兼容性解决方案&quot;">​</a></h3><p>需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法:</p><ol><li>声明了 DTD，使用 document.documentElement.scrollTop</li><li>未声明 DTD，使用 document. body.scrollTop</li><li>新方法 window.pageYoffset 和 window.pagexoffset，IE9 开始支持</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getScroll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    left:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      window.pageXOffset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.documentElement.scrollLeft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.body.scrollLeft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    top: window.pageYOffset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.documentElement.scrollTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.body.scrollTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用的时候 getScroll().left</span></span></code></pre></div><h3 id="_3-4-三大系列总结" tabindex="-1">3.4 三大系列总结 <a class="header-anchor" href="#_3-4-三大系列总结" aria-label="Permalink to &quot;3.4 三大系列总结&quot;">​</a></h3><table tabindex="0"><thead><tr><th>三大系列大小对比</th><th>作用</th></tr></thead><tbody><tr><td>element.offsetWidth</td><td>返回自身包括 padding、边框、内容区的宽度，返回数值不带单位</td></tr><tr><td>element.clientWidth</td><td>返回自身包括 padding 、内容区的宽度，不含边框，返回数值不带单位</td></tr><tr><td>element.scrollWidth</td><td>返回自身实际的宽度，不含边框，返回数值不带单位</td></tr></tbody></table><p><img src="`+i+'" alt="y5I9zUCTPqr2DAN" loading="lazy"></p><p>他们主要用法：</p><ol><li>offset 系列 经常用于获得元素位置 <strong>offsetLeft offsetTop</strong></li><li>client 经常用于获取元素大小 <strong>clientWidth clientHeight</strong></li><li>scroll 经常用于获取滚动距离 <strong>scrollTop scrollLeft</strong></li><li><strong>注意页面滚动的距离通过</strong> window.pageXOffset 获得</li></ol><h3 id="_3-5mouseenter-和-mouseover-的区别" tabindex="-1">3.5mouseenter 和 mouseover 的区别 <a class="header-anchor" href="#_3-5mouseenter-和-mouseover-的区别" aria-label="Permalink to &quot;3.5mouseenter 和 mouseover 的区别&quot;">​</a></h3><p><strong>mouseenter 鼠标事件</strong></p><ul><li>当鼠标移动到元素上时就会触发 mouseenter 事件</li><li>类似 mouseover，它们两者之间的差别是</li><li>mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter 只会经过自身盒子触发</li><li>之所以这样，就是因为 mouseenter 不会冒泡</li><li>跟 mouseenter 搭配鼠标离开 mouseleave 同样不会冒泡</li></ul><h2 id="_4-动画函数封装" tabindex="-1">4. 动画函数封装 <a class="header-anchor" href="#_4-动画函数封装" aria-label="Permalink to &quot;4. 动画函数封装&quot;">​</a></h2><h3 id="_4-1-动画实现原理" tabindex="-1">4.1 动画实现原理 <a class="header-anchor" href="#_4-1-动画实现原理" aria-label="Permalink to &quot;4.1 动画实现原理&quot;">​</a></h3><p><strong>核心原理</strong>：通过定时器 setInterval() 不断移动盒子位置。</p><p>实现步骤：</p><ol><li>获得盒子当前位置</li><li>让盒子在当前位置加上 1 个移动距离</li><li>利用定时器不断重复这个操作</li><li>加一个结束定时器的条件</li><li>注意此元素需要添加定位，才能使用 element.style.left</li></ol><h3 id="_4-2-动画函数简单封装" tabindex="-1">4.2 动画函数简单封装 <a class="header-anchor" href="#_4-2-动画函数简单封装" aria-label="Permalink to &quot;4.2 动画函数简单封装&quot;">​</a></h3><p>注意函数需要传递 2 个参数，<strong>动画对象</strong>和<strong>移动到的距离</strong>。</p><h3 id="_4-3-动画函数给不同元素记录不同定时器" tabindex="-1">4.3 动画函数给不同元素记录不同定时器 <a class="header-anchor" href="#_4-3-动画函数给不同元素记录不同定时器" aria-label="Permalink to &quot;4.3 动画函数给不同元素记录不同定时器&quot;">​</a></h3><p>如果多个元素都使用这个动画函数，每次都要 var 声明定时器。我们可以给不同的元素使用不同的定时器（自 己专门用自己的定时器）。</p><p>核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。</p><h3 id="_4-4-缓动效果原理" tabindex="-1">4.4 缓动效果原理 <a class="header-anchor" href="#_4-4-缓动效果原理" aria-label="Permalink to &quot;4.4 缓动效果原理&quot;">​</a></h3><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p><p>思路：</p><ol><li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。</li><li>核心算法： (目标值 - 现在的位置 ) / 10 做为每次移动的距离 步长</li><li>停止的条件是： 让当前盒子位置等于目标位置就停止定时器</li><li>注意步长值需要取整</li></ol><h4 id="_4-5-动画函数多个目标值之间移动" tabindex="-1">4.5 动画函数多个目标值之间移动 <a class="header-anchor" href="#_4-5-动画函数多个目标值之间移动" aria-label="Permalink to &quot;4.5 动画函数多个目标值之间移动&quot;">​</a></h4><p>可以让动画函数从 800 移动到 500。</p><p>当我们点击按钮时候，判断步长是正值还是负值</p><ol><li>如果是正值，则步长 往大了取整</li><li>如果是负值，则步长 向小了取整</li></ol><h3 id="_4-6-动画函数添加回调函数" tabindex="-1">4.6 动画函数添加回调函数 <a class="header-anchor" href="#_4-6-动画函数添加回调函数" aria-label="Permalink to &quot;4.6 动画函数添加回调函数&quot;">​</a></h3><p><strong>回调函数原理</strong>：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后， 再执行传进去的这个函数，这个过程就叫做<strong>回调</strong>。</p><p>回调函数写的位置：定时器结束的位置。</p><h3 id="_4-7-动画函数封装到单独-js-文件里面" tabindex="-1">4.7 动画函数封装到单独 JS 文件里面 <a class="header-anchor" href="#_4-7-动画函数封装到单独-js-文件里面" aria-label="Permalink to &quot;4.7 动画函数封装到单独 JS 文件里面&quot;">​</a></h3><p>因为以后经常使用这个动画函数，可以单独封装到一个 JS 文件里面，使用的时候引用这个 JS 文件即可。</p><ol><li>单独新建一个 JS 文件。</li><li>HTML 文件引入 JS 文件。</li></ol><h2 id="_5-常见网页特效案例" tabindex="-1">5. 常见网页特效案例 <a class="header-anchor" href="#_5-常见网页特效案例" aria-label="Permalink to &quot;5. 常见网页特效案例&quot;">​</a></h2><h3 id="_5-1-节流阀" tabindex="-1">5.1 节流阀 <a class="header-anchor" href="#_5-1-节流阀" aria-label="Permalink to &quot;5.1 节流阀&quot;">​</a></h3><p>防止轮播图按钮连续点击造成播放过快。</p><p>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p><p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p><p>开始设置一个变量 var flag = true;</p><p>If(flag) {flag = false; do something} 关闭水龙头</p><p>利用回调函数 动画执行完毕， flag = true 打开水龙头</p>',65),o=[r];function n(d,h,p,c,f,k){return a(),e("div",null,o)}const m=t(s,[["render",n]]);export{u as __pageData,m as default};
