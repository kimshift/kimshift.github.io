import{_ as s,q as i,p as a,aE as t}from"./chunks/framework.-H45_L2h.js";const n="/assets/image-20210222144845933.BWG5v0VU.png",l="/assets/image-20210222145110123.C2OM81bT.png",h="/assets/image-20210222145216551.DeGmnnqF.png",u=JSON.parse('{"title":"1.js面向对象编程","description":"","frontmatter":{"title":"1.js面向对象编程","date":"2023-06-02T13:56:09.000Z","categories":["前端开发"],"tags":["javascript","js进阶"],"prev":"../js基础/6.本地存储","next":"2.js函数进阶"},"headers":[],"relativePath":"技术文章/前端开发/javascript/js进阶/1.js面向对象编程.md","filePath":"技术文章/前端开发/javascript/js进阶/1.js面向对象编程.md","lastUpdated":1723096133000}'),p={name:"技术文章/前端开发/javascript/js进阶/1.js面向对象编程.md"},e=t(`<h1 id="_1-js-面向对象编程" tabindex="-1">1.js 面向对象编程 <a class="header-anchor" href="#_1-js-面向对象编程" aria-label="Permalink to &quot;1.js 面向对象编程&quot;">​</a></h1><h2 id="_1-面向对象编程介绍" tabindex="-1">1. 面向对象编程介绍 <a class="header-anchor" href="#_1-面向对象编程介绍" aria-label="Permalink to &quot;1. 面向对象编程介绍&quot;">​</a></h2><h3 id="_1-1-两大编程思想" tabindex="-1">1.1 两大编程思想 <a class="header-anchor" href="#_1-1-两大编程思想" aria-label="Permalink to &quot;1.1 两大编程思想&quot;">​</a></h3><ul><li>面向过程</li><li>面向对象</li></ul><h3 id="_1-2-面向过程编程-pop-process-oriented-programming" tabindex="-1">1.2 面向过程编程 POP(Process-oriented programming) <a class="header-anchor" href="#_1-2-面向过程编程-pop-process-oriented-programming" aria-label="Permalink to &quot;1.2 面向过程编程 POP(Process-oriented programming)&quot;">​</a></h3><p><strong>面向过程</strong>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p><p>举个栗子：将大象装进冰箱，面向过程做法。</p><p><strong>面向过程，就是按照我们分析好了的步骤，按照步骤解决问题。</strong></p><h3 id="_1-3-面向对象编程-oop-object-oriented-programming" tabindex="-1">1.3 面向对象编程 OOP (Object Oriented Programming) <a class="header-anchor" href="#_1-3-面向对象编程-oop-object-oriented-programming" aria-label="Permalink to &quot;1.3 面向对象编程 OOP (Object Oriented Programming)&quot;">​</a></h3><p><strong>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</strong></p><p>举个栗子：将大象装进冰箱，面向对象做法。 先找出对象，并写出这些对象的功能：</p><ol><li><p>大象对象<br> 进去</p></li><li><p>冰箱对象 打开 关闭</p></li><li><p>使用大象和冰箱的功能</p></li></ol><p>面向对象是以对象功能来划分问题，而不是步骤。</p><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。 面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。</p><p>面向对象的特性：</p><ul><li>封装性</li><li>继承性</li><li>多态性</li></ul><h3 id="_1-4-面向过程和面向对象的对比" tabindex="-1">1.4 面向过程和面向对象的对比 <a class="header-anchor" href="#_1-4-面向过程和面向对象的对比" aria-label="Permalink to &quot;1.4 面向过程和面向对象的对比&quot;">​</a></h3><p><strong>面向过程</strong></p><ul><li>优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul><p><strong>面向对象</strong></p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul><p>用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。</p><h2 id="_2-构造函数和原型" tabindex="-1">2. 构造函数和原型 <a class="header-anchor" href="#_2-构造函数和原型" aria-label="Permalink to &quot;2. 构造函数和原型&quot;">​</a></h2><h3 id="_2-1-概述" tabindex="-1">2.1 概述 <a class="header-anchor" href="#_2-1-概述" aria-label="Permalink to &quot;2.1 概述&quot;">​</a></h3><p>在典型的 OOP 的语言中（如 Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在 ES6 之前， JS 中并没用引入类的概念。 ES6， 全称 ECMAScript 6.0 ，2015.06 发版。但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。 在 ES6 之前 ，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。</p><p>创建对象可以通过以下三种方式：</p><ol><li>对象字面量</li><li>new Object()</li><li>自定义构造函数</li></ol><h3 id="_2-2-构造函数" tabindex="-1">2.2 构造函数 <a class="header-anchor" href="#_2-2-构造函数" aria-label="Permalink to &quot;2.2 构造函数&quot;">​</a></h3><p><strong>构造函数</strong>是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><p>在 JS 中，使用构造函数时要注意以下两点：</p><ol><li>构造函数用于创建某一类对象，其<strong>首字母要大写</strong></li><li>构造函数要<strong>和 new 一起使用</strong>才有意义</li></ol><p>new 在执行时会做四件事情：</p><ol><li>在内存中创建一个新的空对象。</li><li>让 this 指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面不需要 return ）。</li></ol><p>JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为<strong>静态成员</strong>和<strong>实例成员</strong>。</p><p><strong>静态成员</strong>：在构造函数本上添加的成员称为<strong>静态成员，只能由构造函数本身来访问</strong><strong>实例成员</strong>：在构造函数内部创建的对象成员称为<strong>实例成员，只能由实例化的对象来访问</strong></p><h3 id="_2-3-构造函数的问题" tabindex="-1">2.3 构造函数的问题 <a class="header-anchor" href="#_2-3-构造函数的问题" aria-label="Permalink to &quot;2.3 构造函数的问题&quot;">​</a></h3><p>构造函数方法很好用，但是存在浪费内存的问题。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Star</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">uname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.uname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uname</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;我会唱歌&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ldh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Star</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;刘德华&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zxy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Star</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张学友&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？</p><h3 id="_2-4-构造函数原型-prototype" tabindex="-1">2.4 构造函数原型 prototype <a class="header-anchor" href="#_2-4-构造函数原型-prototype" aria-label="Permalink to &quot;2.4 构造函数原型 prototype&quot;">​</a></h3><p>构造函数通过原型分配的函数是所有对象所<strong>共享的</strong>。</p><p>JavaScript 规定，<strong>每一个构造函数都有一个 prototype 属性</strong>，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p><strong>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</strong></p><ol><li>原型是什么 ？ 一个对象，我们也称为 prototype 为原型对象。</li><li>原型的作用是什么 ？ 共享方法。</li></ol><h3 id="_2-5-对象原型-proto" tabindex="-1">2.5 对象原型 <code>__proto__</code> <a class="header-anchor" href="#_2-5-对象原型-proto" aria-label="Permalink to &quot;2.5 对象原型 \`__proto__\`&quot;">​</a></h3><p>对象都会有一个属性 <code>__proto__</code>指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 <code>__proto__</code>原型的存在。</p><ul><li><p><code>__proto__</code>对象原型和原型对象 prototype 是等价的</p></li><li><p><code>__proto__</code>对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</p></li></ul><p><img src="`+n+'" alt="image-20210222144845933" loading="lazy"></p><h3 id="_2-6-constructor-构造函数" tabindex="-1">2.6 constructor 构造函数 <a class="header-anchor" href="#_2-6-constructor-构造函数" aria-label="Permalink to &quot;2.6 constructor 构造函数&quot;">​</a></h3><p><strong>对象原型（ <code>__proto__</code>）<strong>和</strong>构造函数（prototype）原型对象</strong>里面都有一个属性 <strong>constructor</strong> 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</p><p>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p><p><strong>一般情况下，对象的方法都在构造函数的原型对象中设置</strong>。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><h3 id="_2-7-构造函数、实例、原型对象三者之间的关系" tabindex="-1">2.7 构造函数、实例、原型对象三者之间的关系 <a class="header-anchor" href="#_2-7-构造函数、实例、原型对象三者之间的关系" aria-label="Permalink to &quot;2.7 构造函数、实例、原型对象三者之间的关系&quot;">​</a></h3><p><img src="'+l+'" alt="image-20210222145110123" loading="lazy"></p><h3 id="_2-8-原型链" tabindex="-1">2.8 原型链 <a class="header-anchor" href="#_2-8-原型链" aria-label="Permalink to &quot;2.8 原型链&quot;">​</a></h3><p><img src="'+h+`" alt="image-20210222145216551" loading="lazy"></p><h3 id="_2-9-javascript-的成员查找机制-规则" tabindex="-1">2.9 JavaScript 的成员查找机制(规则) <a class="header-anchor" href="#_2-9-javascript-的成员查找机制-规则" aria-label="Permalink to &quot;2.9 JavaScript 的成员查找机制(规则)&quot;">​</a></h3><ol><li>当访问一个对象的属性（包括方法）时，首先查找这个<strong>对象自身</strong>有没有该属性。</li><li>如果没有就查找它的原型（也就是 <code>__proto__</code>指向的 <strong>prototype 原型对象</strong>）。</li><li>如果还没有就查找原型对象的原型（<strong>Object 的原型对象</strong>）。</li><li>依此类推一直找到 Object 为止（<strong>null</strong>）。</li><li><code>__proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li></ol><h4 id="_2-10-原型对象-this-指向" tabindex="-1">2.10 原型对象 this 指向 <a class="header-anchor" href="#_2-10-原型对象-this-指向" aria-label="Permalink to &quot;2.10 原型对象 this 指向&quot;">​</a></h4><p>构造函数中的 this 指向我们实例对象. <strong>原型对象</strong>里面放的是方法, 这个方法<strong>里面的 this 指向</strong>的是 这个方法的调用者, 也就是这个<strong>实例对象</strong>.</p><h3 id="_2-11-扩展内置对象" tabindex="-1">2.11 扩展内置对象 <a class="header-anchor" href="#_2-11-扩展内置对象" aria-label="Permalink to &quot;2.11 扩展内置对象&quot;">​</a></h3><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p><p><strong>注意</strong>：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p><h2 id="_3-es6-之前的继承" tabindex="-1">3. ES6 之前的继承 <a class="header-anchor" href="#_3-es6-之前的继承" aria-label="Permalink to &quot;3. ES6 之前的继承&quot;">​</a></h2><p>ES6 之前并没有给我们提供 extends 继承。我们可以通过<strong>构造函数+原型对象</strong>模拟实现继承，被称为<strong>组合继承</strong>。</p><h3 id="_3-1-call" tabindex="-1">3.1 call() <a class="header-anchor" href="#_3-1-call" aria-label="Permalink to &quot;3.1 call()&quot;">​</a></h3><p>调用这个函数, 并且修改函数运行时的 this 指向</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun.call(thisArg, arg1, arg2, ...)</span></span></code></pre></div><ul><li>thisArg ：当前调用函数 this 的指向对象</li><li>arg1，arg2：传递的其他参数</li></ul><h3 id="_3-2-借用构造函数继承父类型属性" tabindex="-1">3.2 借用构造函数继承父类型属性 <a class="header-anchor" href="#_3-2-借用构造函数继承父类型属性" aria-label="Permalink to &quot;3.2 借用构造函数继承父类型属性&quot;">​</a></h3><p>核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sex</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Student</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">score</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name, age, sex) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此时父类的 this 指向子类的 this，同时调用这个函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> score</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Student</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;男&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s1)</span></span></code></pre></div><h3 id="_3-3-借用原型对象继承父类型方法" tabindex="-1">3.3 借用原型对象继承父类型方法 <a class="header-anchor" href="#_3-3-借用原型对象继承父类型方法" aria-label="Permalink to &quot;3.3 借用原型对象继承父类型方法&quot;">​</a></h3><p><strong>一般情况下</strong>，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。<br><strong>核心原理</strong>：</p><ol><li>将子类所共享的方法提取出来，让子类的 <strong>prototype 原型对象 = new 父类()</strong></li><li>本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</li><li>将子类的 constructor 从新指向子类的构造函数</li></ol>`,75),r=[e];function k(o,d,g,E,c,y){return a(),i("div",null,r)}const F=s(p,[["render",k]]);export{u as __pageData,F as default};
